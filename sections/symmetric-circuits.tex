\documentclass[../paper.tex]{subfiles}
%\usepackage{../mymacros}
\begin{document}
% Note: include circuits in background
Boolean circuits have long been as an alternative model from which to study
algorithmic complexity. A circuit is evaluated for some ordered binary input
sequence by recursively evaluating each gate in the circuit, starting from the
input gates. Suppose then we are evaluating some gate $g$ in a circuit $C$. The
procedure involves taking the input string formed by evaluating all gates input
to $g$ and applying the Boolean function that labels $g$ to that string. But
this process assumes an externally-imposed ordering on the gates input to $g$;
an assumption common in most parts of complexity theory, where the encoding of
structures for computation induces such orderings, but not in finite model
theory.

Circuit models have also been studied in finite model theory as a means for
characterising the expressive power of logics. In particular, research has
focused on symmetric circuits defined over bases of symmetric Boolean functions
(see \cite{}). The fact that the basis consist of only symmetric functions is a
crucial requirement, ensuring that the evaluation of a gate does not depend on
the order.

In this section we extend the circuit model so as to allow us to define
symmetric circuits over a broader basis of functions. We introduce the notion of
a structured function , i.e. a Boolean function whose input is indexed in
accordance with some many-sorted structure. This allows us to characterise many
natural symmetry properties of structured functions in terms of equally natural
symmetry properties of many-sorted structures. We use this to derive a general
symmetry conditions on structured functions and a symmetric circuit model whose
basis elements are symmetric structured functions.

% We incorporate this labelling in the circuit model by including for each gate
% $g$ labelled by a structured function $$an indexing on its children that
% matches the index for the function that labels $g$. We allow these circuits to
% be defined over bases of structured functions with this more general symmetry
% condition

% In order then to include a gate computing rank in our symmetric circuit model
% we need to rec We are interested in circuit with gates that can compute rank
% and so, since rank is not a symmetric function, we develop a symmetric circuit
% model capable of incorporating non-symmetric functions in its basis. Moreover,
% we note that

% In particular, we are interested in Boolean functions that compute rank, i.e.
% functions that take in a binary matrix and compute the rank of that matrix
% over some prime field and compare the result with some threshold. But clearly
% this rank function is not symmetric. Furthermore, its evaluation depends on
% how the input set is labelled to form a matrix.

% In this section we develop the

% allowing us to develop natural symmetry conditions on the functions in terms
% of symmetry conditions on the structure. This indexing allows us to generalise
% the notion of a symmetric function by relativising the symmetry condition in
% accord with the structure on the input string. Incorporating this indexing
% into the circuit and



% ore recently, they have played a role in finite model theory, with many
% authors (e.g. ) studying circuit models that take in some representation of a
% finite algebraic structure and which obey certain natural symmetry conditions.
% However, there are some subtleties in the definition and evaluation of
% circuits which must be considered carefully and have important implications
% for the notion of a symmetric circuit studied in this paper. Let $C$ be a
% Boolean circuit $g$ be an internal gate labelled by some function $f_g:
% \{0,1\}^{A} \rightarrow \{0,1\}$, for some index set $A$ with $\vert A \vert =
% \vert H_g \vert$. Formally, evaluating $g$ requires a (usually bijective)
% indexing function $f_i: A \mapsto H_g$, which organises the inputs of $g$ into
% an appropriate sequence. The evaluation of $g$ is then given by $C[\vec{x}](g)
% = f_g (a \mapsto C[\vec{x}](f_i(a)))$. As such the evaluation of a gate in a
% circuit may depend on how the inputs to the gate are indexed.

% In most contexts in complexity theory, circuits may be taken to be implicitly
% ordered objects and so this indexing function can be defined as taking the
% $i$th element of $A$ to the $i$th element of $H_g$. However, in general this
% renders the evaluation of a circuit for a given input a property both of the
% circuit and an arbitrary order. In order to address this problem this problem
% many authors only define circuits over Boolean bases of symmetric functions
% (e.g. the standard basis or the majority basis). In this case the evaluation
% of a gate is independent of the choice of indexing function.

% However, in this paper we require gates labelled by Boolean rank functions,
% i.e. a function that takes in a Boolean sequence indexed by `row' and `column'
% sets, outputs 1 iff that matrix, when interpreted as having entries in
% $\mathbb{F}_p$, has rank at least $r$. These rank functions clearly depend on
% how the input sequence is labelled, and so are not symmetric. However, it is
% worth noting that while such rank functions may be symmetric, they are
% symmetric in the weaker sense of being constant under permutations on the rows
% and columns of the input matrix.

% Motivated by the desire to study circuits with gates that compute rank, We
% develop a general framework for circuits that allows gates to be labelled by
% Boolean functions of the form $F: \{0,1\}^{X} \rightarrow \{0, 1\}$, where the
% labelling $X$ is the universe of a many-sorted structure over some vocabulary
% $\tau$. The Moreover, we generalise the notion of a circuit for structures
% (see Anderson and Dawar \cite{AndersonD17}), incorporate an appropriate
% labelling for the inputs of each gate and allowing for a Boolean basis
% including non-symmetric functions. Furthermore, the vocabulary $\tau$ will
% allow us to impose natural symmetry conditions on $F$, and so allowing us to
% develop a useful notion of a symmetric circuit.

% We also prove that no family symmetric functions defined over a basis of
% symmetric functions can improve on the expressive power of the circuit model
% of Anderson and Dawar \cite{AndersonD17}. Together with the main theorem of
% this paper this implies that these more general symmetric circuits are
% strictly more powerful

% consider the problem of explicitly labelling the input of the function both so
% that the semantics of the function can be reasonably defined and so as to
% ensure that appropriate symmetry conditions on the function can be enforced.


% labelled by functions that are not symmetric, we need to think explicitly
% about how the input is to be labelled and how that structure should be
% mirrored in the circuit definition. In particular, we should like to consider
% functions which invariant under some action and so choose labellings which
% appropriately reflect the required symmetry conditions of the function.

% In this section we first discuss how to structure the input to a Boolean
% function appropriately and how symmetries on that input structure induce
% useful symmetries on the function.

\subsection{Structured Functions and Symmetry}
Before we begin this section let us review Boolean circuits and a few useful
symmetry conditions placed on these circuits. Let $X$ be a finite set and $F:
\{0,1\}^{X} \rightarrow \{0,1\}$ be a Boolean function. We call $X$ the
\emph{index} of $F$, and denote it by $\ind(F)$. It is often the case that the
index $X$ is in some sense structured, but let us first consider the case where
$X$ is an unstructured set. In this case the only natural symmetry condition to
consider is where $F$ is invariant under the action of $\sym_n$, i.e. $F$ is a
symmetric function. Suppose instead $X$ consists of all two element subsets of
the set $V$. Here we can think of $X$ as representing all potential edges in a
graph, and $\vec{x} \in \{0,1\}^X$ as defining a graph. It is natural then to
consider the case where $F$ determines a property of the graph, i.e. where $F$
is invariant under the action of $\sym_V$ on the input (i.e renaming of the
vertices). We call such a function \emph{graph-invariant}. Suppose that $X := A
\times B$ for two non-empty sets $A$ and $B$. Here we can think of $\vec{x} \in
\{0,1\}^X$ as an (unordered) matrix, and we can consider the case where $F$ is
invariant under the action of $\sym_A \times \sym_B$. In this case we say $F$ is
\emph{matrix-invariant}. Notice that in each of these cases the symmetry
condition of interest on the function was related to the structure of the index
set.

In the rest of this subsection we develop the notion of structured function, a
Boolean function whose input is structured in accord with some structure and
whose natural symmetry conditions follow from similar conditions on the
structure.


% $X:= {n}\choose{2}$, for some $n$, we can think of $F$ as taking in some $n$
% vertex graph, and we should like $F$ to respect permutations on the graph. In
% this case we insist that $F$ is a \emph{graph symmetric} function, for all $$
% where we can think of $F$ as taking in a graph with $n$ vertices, where $X:=
% {n}\choose{2}$ as indexing a graph with $n$ vertices

% The set $X$ is often used just to provide an ordering, and so $F$ just takes
% in a binary $\vert X \vert$-tuple. While in general the order of the input
% sequence matters, it is common to consider the case where $F$ is a
% \emph{symmetric} Boolean function, i.e. for all $\sigma \in \sym_{X}$,
% $\vec{x} \in \{0,1\}^{X}$, $F(\vec{x}\cdot \sigma) = \vec{x}$. In this case
% the output of the function is independent of the ordering on the input tuple.
% Indeed, many natural Boolean functions (e.g. `and', `or', `not', `majority',
% etc.) are symmetric functions. One of the benefits of considering symmetric
% functions

Let $\tau = (R, S, \nu)$ be a many-sorted, relational signature, with $R = \{R_1
\ldots, R_t\}$ and $S = [s]$ for some $s \in \nats$, and $\nu(R_i) = (a^i_1,
\ldots , a^i_{r_i)})$, where $r_i = \arty(R_i)$ and $a^i_q \in S$ for all $q \in
[r_i]$. Let $\mathcal{D}$ be a $\tau$-structure, with the universe $D = D_1
\uplus \ldots \uplus D_s = \{(i,d) : d \in D_i\}$.

Let the \emph{index-domain} of $\mathcal{D}$ be $\rdom {\mathcal{D}} = \{(i, j)
:= i \in [r_j], R_j \text{ a relation in $\tau$} \}$. Let the \emph{index
  defined by} $\mathcal{D}$ be the set of all functions $f: \rdom(\mathcal{D})
\rightarrow D$ such that for all $R_j \in R$ and $i \in [r_j]$, $f(i, j) \in
A_{a^{j}_i}$. We abuse notation and denote the index defined by
$\ind(\mathcal{D})$. We note that, since the set of relation symbols and sort
symbols are ordered, we can also think of each $f \in \ind(\mathcal{D})$ as a
tuple in $D_{a^1_1} \times \ldots \times D_{a^1_{r_1}} \times \ldots \times
D_{a^t_1} \times D_{a^t_{r_t}}$. We will use these tuples in order to index the
inputs to a Boolean function.

For the remainder of the section fix a $\tau$-structure $\mathcal{D}$ and let $X
:= \ind (\mathcal{D})$. Let $G \leq \sym_{X}$. We note that there is a natural
action of $G$ on $X$. Furthermore, we can define an action of $G$ on functions
of the form $f: X \rightarrow H$, for any set $H$, given by $\sigma \cdot f(x) =
f(\sigma \cdot x)$ for all $x \in X$. If $H = \{0,1\}$ we say that $f$ is a
\emph{binary sequence indexed by $X$}. If $H$ is surjective, we say that
\emph{$f$ indexes $H$ by $X$} or \emph{$f$ indexes $H$ by $\mathcal{D}$}. We
note that $\aut(\mathcal{D})$ and $\iso(\mathcal{D})$ can be identified with
subgroups of $\sym_X$.

We develop a notion of equivalence from this action. Say that two functions $f,
g : X \rightarrow H$ are \emph{$G$-equivalent} iff there exists $\sigma \in G$
such that $f(x) = f(\sigma \cdot x)$ for all $x \in X$. We say $f$ and $g$ are
\emph{isomorphism-equivalent} if they are $\iso(\mathcal{D}$-equivalent. We say
that $f$ and $g$ are \emph{automorphism-equivalent} if they are $
\aut(\mathcal{D})$-equivalent. We say that $f$ and $g$ are
\emph{sort-equivalent} in the special case where every relation in $\mathcal{D}$
contains all possible tuples and $f$ and $g$ are automorphism-equivalent.

We call a function of the form $F:\{0,1\}^{X} \rightarrow \{0,1\}$ a
\emph{$\mathcal{D}$-structured function}. We note that $\ind(F) =
\ind(\mathcal{D})$, justifying our above choice of notation. We also say
\emph{the vocabulary of $F$} and \emph{the universe of $F$} to refer to the
vocabulary and universe of $\mathcal{D}$.

% It is easy to see that if $\mathcal{C}_A$ is the category with objects given
% by $\tau$-structures over $A$ and morphisms by the action of $G$, and
% $\mathcal{C}_X$ is the category of subsets of $X^{\tau}_A$ with morphisms
% similarly given by the action of $G$, then these two categories are
% equivalent. More informally, the subsets of $X^{\tau}_A$ encode the
% $\tau$-structures over $A$. This relationship is bijective and the action of
% $G$ factors through this bijection.

% \begin{remark}
%   Is the categorical language unnecessary? It seemed the quickest way of
%   saying what I wanted to say formally.
% \end{remark}

% \begin{remark}
%   In the above section (and just below) we talk about the action of
%   $\sym_{A_{s_1}} \times \ldots \times \sym_{A_{s_p}}$ on elements of
%   $X^\tau_A$ and structured functions. In the proof of the support theorem,
%   when defining a definable matrix for converting circuits into formulas, and
%   later on in this section, it is useful to speak more generally and instead
%   look at bijections from $A_1, \ldots A_{s_p}$ to $B_1, \ldots, B_{s_p}$,
%   thus allowing us to map between $X^\tau_A$ and $X^\tau_B$ and so between the
%   associated structured functions. I've added this in later on in the section,
%   but I still need to incorporate it into the original definition (it's a more
%   general notion in a sense, and so I think it should be incorporated). I'll
%   wait for feedback before doing this as I'm not sure this formulation will
%   survive.
% \end{remark}

These structured functions give us a general framework for indexing the input to
functions while also providing us with a natural set of groups from which to
develop symmetry conditions for Boolean functions. We now introduce some of
these conditions. Let $F$ be a $\mathcal{D}$-structured function. We say $F$ is
\emph{$G$-invariant} if it constant on $G$-equivalent input vectors, i.e. for
all $G$-equivalent $\vec{x},\vec{y} \in \{0,1\}^{X}$, $F(\vec{x}) = F(\vec{y})$.
Similarly, we say $F$ is \emph{automorphism-invariant} if it is constant on
automorphism-equivalent input vectors and \emph{isomorphism-invariant} if it is
constant on isomorphism-equivalent input vectors. If all the relations in
$\mathcal{D}$ contain all possible tuples, and $F$ is automorphism-invariant,
then we say that $F$ is \emph{sort-invariant}. If the vocabulary of $F$ has two
sorts $s_1, s_2$ and one binary relation $R$ with type $(s_1, s_2)$ and $F$ is
sort-invariant, then we say $F$ is \emph{matrix-invariant}.

Notice that if $\tau$ is the empty vocabulary and $\mathcal{D}$ is a
$\tau$-structure, i.e. $\mathcal{D}$ is a pure set, then any
$\mathcal{D}$-structured function $F$ is automorphism-invariant (or
isomorphism-invariant) if, and only if, $F$ is symmetric. Also, if $\mathcal{D}$
is a graph, then $F$ is isomorphism invariant if, and only if, $F$ is
graph-invariant (except with a slight alteration, here $F$ takes in the edge
relation rather than a binary string indexed by two element sets of vertices).
Similarly, $F$ is matrix invariant (as a structured function) if, and only if,
it is matrix-invariant in the sense defined right at the beginning of this
subsection. In each of these cases choosing an appropriate structure leads to an
appropriate index and an appropriate notion of symmetry. In this way structured
functions generalise the notion of a symmetric function and allow us to capture
a broad range of structure-specific symmetry conditions in a single definition.
In the next section we will show how to define a circuit and a symmetric circuit
using bases of structured functions.


% Let $F$ be a $(\tau, A)$-structured function with $\tau = (\{R\}, \{1\},
% \nu)$, where $R$ is a binary relation. Let $G \leq \sym_A$ such that for any
% $v, w \in A$ We say $F$ is \emph{graph-symmetric} if $F$ is $(\tau, A)$simple
% and matrix-symmetric.

% If $\tau$ is single-sorted we call $F$ \emph{simple} and if it consists of a
% single unary relation, we call $F$ \emph{unary-relational}.



% We briefly introduce notions of equivalence useful for comparing functions.
% \begin{definition}
%   Let $\tau = (R, S, \nu)$ be a many-sorted signature and let $A = A_1 \times
%   \ldots A_s$ and $B = B_1 \times \ldots \times B_s$ be a product of non-empty
%   sets. A \emph{sorted bijection} between $A$ and $B$ is a function bijections
%   $f: A \rightarrow B$ such that $f (A_i) = B_i$ for all $i \in S$. There is
%   an obvious action of $f$ that maps $X^\tau_A$ to $X^\tau_B$ and
%   $\{0,1\}^{X^\tau_A}$ to $\{0,1\}^{X^\tau_B}$.

%   Let $L: X^\tau_A \rightarrow H$ and $L': X^\tau_B \rightarrow H$ be two
%   functions for some finite set $H$. We say that $L \sim L'$, or \emph{$L$ is
%   equivalent to $L'$}, if there is a sorted bijection $f: A \rightarrow B$
%   such that for all $x \in X^\tau_A$, $L(x) = L'(f (x))$.

%   Let $F$ be a $(\tau, A)$-structured function and $G$ be a $(\tau,
%   B)$-structured function. Then we say that $F \sim G$, or \emph{$F$ is
%   equivalent to $G$}, if there is a sorted bijection $f: A rightarrow B$ such
%   that for all $\vec{i} \in \{0,1\}^{X^\tau_A}$, $F (\vec{i}) =
%   G(f(\vec{i}))$.
% \end{definition}

% \begin{remark}
%   There is an obvious connection between $\tau$-symmetric functions and
%   generalised quantifiers (or closed classes of structures). Should I include
%   details about this connection? I also feel a lot of dirtiness might be
%   avoidable if we instead recast everything in terms of generalised
%   quantifiers. For one, generalised quantifiers give a natural way of defining
%   a Boolean function for each input universe.
% \end{remark}

\subsection{Symmetric Circuits}
We define a circuit over a basis of structured functions that are not
necessarily symmetric. As such, the circuit must include for each gate $g$ an
index on its children corresponding to the index of the function labelling $g$.

% Having developed the notion of a function that accepts input structured in
% accordance with some vocabulary, we now develop a circuit model which
% incorporates this structure on the inputs of a gate. We use this general
% framework to define the notion of a matrix-symmetric circuit, a circuit with
% gates labelled by matrix-symmetric Boolean functions, and finally we develop
% the notion of a matrix-symmetric circuit with rank.

% Importantly, many natural functions of interest are matrix symmetric. For
% example, the function that computes the rank of the matrix over
% $\mathbb{F}_2$. or a thresholded rank function, for example the rank of the
% matrix over $\mathbb{F}_p$ being larger then $r$, for some particular $(p, r)
% \in \mathbb{N}$.

\begin{definition}[Circuits on Structures]
  Let $\mathbb{B}$ be a basis and $\tau$ be a relational vocabulary, we define a
  \emph{$(\mathbb{B}, \tau)$-circuit} $C_n$ computing a $q$-ary query $Q$ as a
  structure $\langle G, \Omega, \Sigma, \Lambda, L \rangle$.
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G$ is called the set of gates of $C_n$ and $\vert C_n \vert := \vert G
    \vert$.
  \item $\Omega$ is an injective function from $[n]^q$ to $G$. The gates in the
    image of $\Omega$ are called the output gates. When $q = 0$, $\Omega$ is a
    constant function mapping to a single output gate.
  \item $\Sigma$ is a function from $G$ to $\mathbb{B} \uplus \tau \uplus
    \{0,1\} $ such that $\vert \Sigma^{-1} (0) \vert \leq 1$ $\vert \Sigma^{-1}
    (1) \vert \leq 1$. Those gates mapped to $\tau \uplus \{0,1\}$ are called
    input gates, with those mapped to $\tau$ called relational gates and those
    mapped $\{0,1\}$ called constant gates. Those gates mapped to $\mathbb{B}$
    are called internal gates.
  \item $\Lambda$ is a sequence of injective functions $(\Lambda_{R_i})_{R_i \in
      R}$ such that $\Lambda_{R_i}$ maps each relational gate $g$ with $R_i =
    \Sigma (g)$ to the tuple $\Lambda_{R_i} (g) \in [n]^{r}$. When no ambiguity
    arises we write $\Lambda (g)$ for $\Lambda_{R_i} (g)$.
  \item $L$ associates with each internal gate $g$ a function $L(g):
    \dom(\Sigma(g)) \rightarrow G$ such that if we define a relation $W
    \subseteq G^{2}$ by $W(h_1,h_2)$ iff $h_2$ is an internal gate and $h_1$ is
    in the image of $L(h_2)$, then $(G, W)$ is a directed acyclic graph.
  \end{itemize}
\end{definition}

% \begin{definition}[Circuits on Structures]
%   Let $\mathbb{B}$ be a basis of structured functions and $\tau := (R, \{s_1,
%   \ldots, s_p\}, \nu)$ be a many-sorted vocabulary and let $\vec{n} :=
%   (n_{s_1}, \ldots , n_{s_p}) \in \mathbb{N}^{S}$, we define a
%   \emph{$(\mathbb{B}, \tau)$-circuit} $C_{\vec{n}}$ computing a $q$-ary query
%   $Q$ of type $(s^Q_{1}, \ldots , s^Q_{q})$ is a structure $\langle G, W,
%   \Omega, \Sigma, \Lambda, L\rangle$.
%   \begin{itemize}
%     \setlength\itemsep{0mm}
%   \item $G$ is called the set of gates of $C_{\vec{n}}$ and $\vert C_{\vec{n}}
%     \vert := \vert G \vert$.
%   \item $W \subseteq G \times G$, where $W$ is called the wires of the
%     circuit. $(G,W)$ must be a directed acyclic graph. For $g \in G$ we $H_g
%     := \{ h \in G: W(h,g)\}$ be the set of children of $g$.
%   \item $\Omega$ is an injective function from $[n_{i_1}] \times \ldots \times
%     [n_{i_q}]$ to $G$. The gates in the image of $\Omega$ are called the
%     output gates. When $q = 0$, $\Omega$ is a constant function mapping to a
%     single output gate.
%   \item $\Sigma$ is a function from $G$ to $\mathbb{B} \uplus \tau \uplus
%     \{0,1\} $ which maps input gates to $\tau \uplus \{0,1\}$ and where $\vert
%     \Sigma^{-1} (0) \vert \leq 1$ $\vert \Sigma^{-1} (1) \vert \leq 1$ and the
%     internal gates get mapped into $\mathbb{B}$. Gates mapped to $R$ are
%     called relational gates and gates mapped to 1 or 0 are called constant
%     gates.
%   \item $\Lambda$ is a sequence of injective functions $(\Lambda_{R'})_{R' \in
%     R}$ where for each $R' \in R$ with arity $r$ and type $(s^{R'}_{1},
%     \ldots, s^{R'}_{r})$, $\Lambda_{R'}$ maps each relational gate $g$ with
%     $R' = \Sigma (g)$ to the tuple $\Lambda_{R'} (g) \in [n_{s^{R'}_1}] \times
%     \ldots \times [n_{S^{R'}_r}]$. When no ambiguity arises we write $\Lambda
%     (g)$ for $\Lambda_{R'} (g)$.
%   \item $L$ maps to each internal gate a labelling on its children. Let $g$ be
%     an internal gate. We have that $L(g)$ is a surjection from $\ind (\Sigma
%     (g))$ to $H_g$. We call $L(g)$ the \emph{child-labelling} for $g$.
%   \end{itemize}
% \end{definition}

Let $C_n = \langle G, \Omega, \Sigma, \Lambda, L \rangle$ be a $(\mathbb{B},
\tau)$-circuit. The $n$ here denotes that $C_n$ accepts structures of size $n$.
For a gate $g \in C_n$, we define the \emph{index} of $g$, denoted by $\ind(g)$,
as $\ind(\Sigma(g))$ and we let $H_g$ denote the set of all gates in the image
of $L(g)$.

For any two sets $X, Y$ we let $X^{\underline{Y}}$ denote the set of all
injective functions from $Y$ to $X$.

Let $\tau = (R_1, \ldots , R_t)$, $\mathcal{A}$ be a $\tau$-structure of size
$n$, and $\gamma: \in [n]^{\underline{U}}$. Let $\gamma \mathcal{A}$ be the
structure formed by mapping U, the universe of $\mathcal{A}$, in accordance with
$\gamma$. The evaluation of some $(\mathbb{B}, \tau)$-circuit $C$ computing a
q-ary query $Q$ proceeds by recursively evaluating the gates in the circuit. The
evaluation of the gate $g$ using $\gamma$ with input $\mathcal{A}$ is denoted by
$C[\gamma \mathcal{A}](g)$, and is given as follows
\begin{enumerate}
  \setlength\itemsep{0mm}
\item If $g$ is a constant gate then it evaluates to the bit given by
  $\Sigma(g)$.
\item If $g$ is a relational gate then $g$ evaluates to true iff $\gamma
  \mathcal{A} \models \Sigma(g)(\Lambda (g))$.
\item If $g$ is an internal gate such that $\Sigma (g)$ is a
  $\mathcal{D}$-structured function, let $L^{\gamma}_g: \ind(g) \rightarrow
  \{0,1\}$ be defined by $L^{\gamma}_g(x) = C[\gamma \mathcal{A}](L(g)(x))$, for
  all $x \in \ind(g)$. Then $g$ evaluates to true iff $\Sigma(g) (L^{\gamma}_g)
  = 1$.
\end{enumerate}
We say that $C_n$ defines the $q$-ary query $Q \subseteq U^q$ where $\vec{a} \in
Q$ iff $C_n[\gamma \mathcal{A}](\Omega (\gamma \vec{a})) = 1$.

% The circuit $C_n$ The following definition is an important circuit property
% introduced by Anderson and Dawar \cite{AndersonD17}. We introduce it for the
% sake of comparison.

The following circuit condition is from Anderson and Dawar \cite{AndersonD17}.

\begin{definition}[Invariant Circuit]
  Let $C_n$ be a $(\mathbb{B}, \tau)$-circuit, computing some $q$-ary query. We
  say $C_n$ is \emph{invariant} if for every $\tau$-structure $\mathcal{A}$ of
  size $n$, $\vec{a} \in U^{q}$, and $\gamma_1, \gamma_2: [n]^{\underline{U}}$
  we have that $C[\gamma_1 \mathcal{A}](\Omega (\gamma_1 \vec{a})) = C[\gamma_2
  \mathcal{A}](\Omega (\gamma_2 \vec{a}))$.
\end{definition}
In general, the evaluation of a circuit depends on the presentation of the
structure (i.e. on the chosen bijection $\gamma$). If family of $(\mathcal{B},
\tau)$-circuits $\mathcal{C}$ is invariant it follows that the query computed is
a $q$-query on $\tau$-structures. It follows that if $q = 0$ then $\mathcal{C}$
computes a property of $\tau$-structures. The following lemma allows us to
recast this notion in terms of the language developed in this paper.

\begin{lem}
  Let $C_n$ be a $(\mathbb{B}, \tau)$-circuit. The function computed by $C_n$ is
  isomorphism-invariant iff $C_n$ is invariant.
\end{lem}

For the sake of simplicity, from now on we assume the that all circuits take in
structures over a single-sorted vocabulary.

\begin{definition}[Automorphism]
  let $C = \langle G, \Omega, \Sigma, \Lambda, L\rangle$ be a
  $(\mathbb{B},\tau)$-circuit computing a $q$-ary query on structures of size
  $n$, and where $\mathbb{B}$ is a bases of sort-symmetric functions. Let
  $\sigma \in \sym_n$ and $\pi: G \rightarrow G$ be a bijection such that
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item for all gates $g, h \in G$, $W(g,h)$ iff $W(\pi g, \pi h)$,
  \item for all output tuples $x \in [n]^q$, $\pi \Omega (x) = \Omega (\sigma
    x)$,
  \item for all gates $g \in G$, let $\Sigma (g) = \Sigma (\pi g)$,
  \item for each relational gate $g \in G$, $\sigma \Lambda (g) = \Lambda (\pi
    g)$, and
  \item for each internal gate $g$ then we have that $L(\pi g)$ and $ \pi \cdot
    L(g)$ are sort-equivalent.
  \end{itemize}
  We call $\pi$ an \emph{automorphism} of $C$, and we say that $\sigma$
  \emph{extends to the automorphism} $\pi$. The group of automorphisms of $C$ is
  called $\aut_n (C)$.
\end{definition}

\begin{definition}[Symmetry]
  A circuit $C$ on structures of size $n$ is called \emph{symmetric} if every
  $\sigma \in \sym_n$ induces an automorphism on $C$.
\end{definition}

It follows for any symmetric circuit $C_n$ there is a homomorphism $h$ that maps
$\sym_n$ to $\aut_n(C)$. This homomorphism is injective so long as a single
element of $[n]$ appears in the in the label of some input gate of $C$ (as then
all elements appear by symmetry)\cite{AndersonD17}. In this paper we always
assume that there is at least one such element, as otherwise all inputs are
constant, and so the circuit just computes a constant function. In order to
assure this homomorphism is surjective Anderson and Dawar \cite{AndersonD17}
introduce the notion of a \emph{rigid} circuit.

\begin{definition}[Rigidity]
  Let $C_n$ be a $(\mathbb{B}, \tau)$-circuit, where $C_n = \langle G, W,
  \Omega, \Sigma, \Lambda, L\rangle$. Say that $C_n$ is \emph{rigid} if there
  are no distinct internal gates $g, g' \in G$ such that $\Sigma(g) = \Sigma
  (g')$, $\Omega^{-1}(g) = \Omega^{-1}(g')$, $H_g = H_{g'}$ and $L(g')$ and
  $L(g)$ are sort-equivalent.
\end{definition}

Another property which simplifies our analysis is the property of having
\emph{bijective labels}.

\begin{definition}
  We say that a circuit $C$ has \emph{bijective labels} if for each gate $g$ in
  $C$, $L(g)$ is a bijection.
\end{definition}

We prove in a later section that a circuit may be transformed in polynomial time
into an equivalent circuit that is both rigid and has bijective labelings. Hence
we may assume these two properties without a loss of generality.

With the assumption of rigidity in place, we abuse notation for permutations and
let $\sigma \in \sym_n$ also denote the induced automorphism.

We finally want to define a circuits that allow for gates labelled by
matrix-symmetric functions.

\begin{definition}
  Let $\mathbb{B}$ be a basis containing the single-sorted structured functions
  that compute $\land$, $\lor$, $\neg$ and $\maj$ and such that all elements of
  this basis are either matrix-symmetric or simple unary. We call a
  $(\mathbb{B}, \tau)$-circuit a \emph{symmetric matrix-circuit}.
\end{definition}

We define a circuit that has gates that compute rank.
\begin{definition}
  Let the $(\mathbb{B}, \tau)$-circuit $C$ be a matrix-symmetric circuit. Let
  $\mathbb{B}_m \subseteq \mathbb{B}$ consist of all matrix-symmetric functions
  that are not symmetric. For any non-empty sets $A_1, A_2$ and $r, p \in
  \mathbb{N}$, where $p$ prime define a $F_{p,r}: \{0,1\}^{A_1 \times A_2}
  \rightarrow \{0,1\}$ such that $f_{p,r}(M) = 1$ iff the matrix $M: A_1 \times
  B_1 \rightarrow \{0,1\}$ has rank at least $r$ over the field $\mathbb{F}_p$.
  We call such a function a \emph{bounded-rank function}. If $\mathbb{B}_m$ is
  equal to the set of all such bounded-rank functions, then we call $C$ a
  \emph{symmetric rank-circuit}.
\end{definition}

% The natural restriction to consider on families of circuits is uniformity.

% \begin{definition}
%   Let $(C_n)_{n \in \mathbb{N}}$ be a family of Boolean circuits. We say that
%   $(C_n)_{n \in \mathbb{N}}$ is \emph{$P$-uniform} if the mapping $n \mapsto
%   C_n$ is computable in polynomial time.
% \end{definition}

We are now ready to state what will be the main theorem of this paper.
\begin{thm}[Main Theorem]
  A graph property is decidable by a $P$-uniform family of symmetric circuits
  with rank gates if, and only if, it is definable by an $\FPR$ sentence.
\end{thm}

\subsection{Limitations of Symmetric Bases}
When looking at symmetric circuits with matrix symmetric functions, it is
natural to ask if this extension to matrix-symmetric functions is really
necessary. In this section we show that Symmetric circuits, as developed by
Anderson and Dawar, defined over the usual basis with majority gates can compute
any symmetric function over polynomial size circuits. As such no additional
symmetric function added to the Basis improves the power of the model.

Recall from Anderson and Dawar \cite{AndersonD17} we have that
$\mathbb{B}_{\std} = \{ \neg , \wedge , \lor \}$ and $\mathbb{B}_\maj = \{ \maj
\} \cup \mathbb{B}_{\std}$.

Let $F = (F_n: \{0,1\}^n \rightarrow \{0,1\})_{n \in \mathbb{N}}$ be a family of
symmetric Boolean functions. Recall that for any $n \in \mathbb{N}$, the output
of $F_n$ is entirely determined by the number of 1's in its input. Then let
$c_{F}:\mathbb{N} \rightarrow 2^{\mathbb{N}}$ define a function where $c_{F}(n)$
is the set of all $m \leq n$ such that for all $\vec{x} \in \{ 0,1 \}^n$ with
$m$ 1's we have $F_n (\vec{x}) = 1$. Clearly any symmetric Boolean function
$F_n$ is entirely determined by $c_{F}(n)$, and so $F$ is entirely determined by
$C_F$.
 
\begin{prop}
  \label{prop:fuctions-maj}
  Let $F = (F_n: \{0,1\}^n \rightarrow \{0,1\})_{n \in \mathbb{N}}$ be a family
  of symmetric functions. There exists a family of Boolean circuits $(C_n)_{n
    \in \mathbb{N}}$ defined over $\mathbb{B}_\maj$ computing $F$. Moreover,
  $(C_n)_{n \in \nats}$ has depth at most $5$ and width at most $2n+2$ and size
  at most $8n + 3$.
\end{prop}

\begin{proof}
  We define the circuit $C_n$ with $n$ input gates denoted by $x_1, \ldots, x_k$
  by successively adding gates. For $a \in \mathbb{N}$ we add an `and' gate
  $\countgate_a$, and a number of `majority' and `not' gates, wiring them up as
  follows:
  \[
    \countgate_a = \begin{cases} \land ( \maj ( x_1, \ldots, x_n, \underbrace
      {0, \ldots, 0}_{2a - n} ), \neg ( \maj (x_1, \ldots , x_n, \underbrace{0,
        \ldots,
        0}_{2a - n + 2} ) )) &  a \geq \frac{n}{2} \\
      \land ( \maj ( x_1, \ldots, x_n, \underbrace {1, \ldots, 1}_{n - 2a} ),
      \neg ( \maj ( x_1, \ldots , x_n, \underbrace{1, \ldots, 1}_{n - 2a -2} )
      )) & a < \frac{n}{2}.
    \end{cases}
  \]
  
  Clearly $\vert c_F(n) \vert \leq n$, for each $a \in c_F(n)$ we have added
  four gates, so thus far the circuit's width is at most $2n + 2$ (2 extra for
  the possible inclusion of constant gates) and depth at most $4$. Now add to
  $C_n$ a `or' gate $g$ and connect the output of $\countgate_a$ to the input of
  $g$ for each $a \in c_F(n)$. Mark $g$ as the output gate for $C_n$.

  It is easy to see that $C_n$ has depth at most $5$, width at most by $2n + 2$
  and size at most $1 + 4(2n) + 2 = 8n+3$. We have that in each layer of
  $C_{g'}$ each gate is connected to all gates in the previous layer, and as
  such the circuit is symmetric.
\end{proof}

The above proposition has a straight forward application to circuit
characterisations.

\begin{thm}
  Let $\mathcal{F} = \{F_i : i \in I \}$, where $F_i$ is a family of symmetric
  Boolean functions.
  
  Let $(C_n)_{n \in \mathbb{N}}$ be family of symmetric circuits over the
  Boolean basis $\mathbb{B}_{\std} \cup (\bigcup_{i \in I} F_i)$, where $C_n$ is
  a circuit on structures of size $n$, and the size of each circuit in the
  family is bounded by some function $f(n)$. Then there exists a family of
  symmetric circuits $(C_n')_{n \in \mathbb{N}}$ over $\mathbb{B}_\maj$, where
  $C_n'$ is a circuit on structures of size $n$ and $\vert C_n' \vert \leq
  (8f(n) + 3) f(n))$.
\end{thm}

\begin{proof}
  From $C_n$ we construct $C_n'$ as follows. For each gate $g \in C_n$ of
  labelled by a member of $F_i$ we have a symmetric circuit $C_g$ from
  Proposition \ref{prop:function-maj} that computes the same function as $g$.
  Then let $C_n'$ be $C_n$ but with each gate $g$ replaced by $C_g$. It is easy
  to see that $C_n'$ is symmetric. We also have that each gate $g$ must have at
  most $f(n)$ inputs, and so the size of $C_g$ is bounded by $8f(n) + 3$. Thus
  the size of $C_n'$ is bounded by $(8f(n)+3) f(n)$.
\end{proof}

This result gives us that for any family of circuits over an arbitrary basis of
symmetric functions we can can construct another circuit family computing the
same function over the majority basis without a blowup in size. As such, we know
that we cannot extend the power of the symmetric circuits studied by Anderson
and Dawar \cite{AndersonD17} by simply considering alternative bases of
symmetric functions. This result, combined with the main result of this paper,
gives us that symmetric circuits with rank are a strictly more powerful model
than any circuit model defined over a basis of symmetric functions.

\end{document}

