\documentclass[../paper.tex]{subfiles}
\begin{document}
In this section we first introduce a number of useful polynomial-time computable
functions which define transformations on circuits. In the second subsection we
use these functions to define a transformation that takes $\FPR$-formulas to
equivalent families of transparent symmetric rank-circuits.

\subsection{Algorithms for Circuits}
In order to simplify the presentation of the translation between $P$-uniform
families of circuits and formulas of $\FPR$, as well as the proofs of other
results (see Lemma~\ref{lem:transparent-unique}), we define a number of
often-used polynomial-time computable circuit transformations.

We first define the function $\op{merge}$, which maps a circuit and a set of
syntactically-equivalent gates to a circuit formed by combining those gates into
a single gate.

\begin{definition}
  Let $C := \langle G, \Omega, \Sigma , \Lambda, L \rangle$ be a circuit and $H
  := \{h_1, \ldots, h_p\}$ be a set of syntactically equivalent gates. We let
  $\op{merge}(C, H) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{h_2, \ldots, h_p\}$,
  \item $\Omega' = \Omega$,
  \item $\Sigma' = \restr{\Sigma}{G'}$,
  \item $\Lambda' = \Lambda$, and
  \item For all $g \in G'$ and $x \in Ind(g)$ if $L(g) (x) \in H$ then $L'(g)(x)
    = h_1$ and if $L(g)(x) \notin H$ then $L'(g)(x) = L(g)(x)$.
  \end{itemize}
\end{definition}

It can be shown that $\op{merge}$ can be computed in time polynomial in the size
of the input circuit. We note that the input and output circuits compute the
same function. Moreover, if the input circuit is symmetric (resp. has unique
labels, is transparent) then the output circuit will also be symmetric (resp.
have unique labels, transparent).

We now define the function $\op{merge-all}$ which maps a circuit and a set of
gates to a new circuit formed by applying $\op{merge}$ to the
syntactic-equivalence classes of the set of gates.

\begin{definition}
  \label{def:merge-all}
  The function $\op{merge-all}$ maps a circuit $C$ and a set of gates $H$ to a
  circuit $\op{merge-all}(C, H) := C'$, where $C'$ is defined as follows. Let
  $H_1, \ldots, H_p$ be the syntactic equivalence classes of $H$, and let $C'$
  be defined from $C$ by successively applying $\op{merge}$ to each of these
  equivalence classes.
\end{definition}

We can compute $\op{merge-all}$ using the following algorithm. Let $(C, H)$ be a
tuple in the domain of $\op{merge-all}$. We assume a reasonable encoding of the
circuit, and note that any such encoding induces a linear order on the
structure. Let $H_1, \ldots, H_p$ be the syntactic-equivalence classes of $H$
linearly ordered such that for all $i, j \in [p]$ if $i \leq j$ the height of
the gates in $H_i$ is less than or equal to the height of the gates in $H_j$.
Let $C'$ be the result of successively executing the algorithm for $\op{merge}$
on each such equivalence class in order.

It is worth noting that for an input tuple $(C, H)$, if follows from
Lemma~\cite{lem:unique-labels-syntactic-equiv} that if $H$ has unique labels
then the syntactic-equivalence relation on $H$ can be computed in time
polynomial in the size of $C$. Thus, if each gate in $H$ has unique labels, it
can be shown that $\op{merge-all}$ can be computed in time polynomial in the
size of the input circuit.

As in the case of $\op{merge}$, the function $\op{merge-all}$ preserves
symmetry, unique labels and the ensures that the input and output circuits
compute the same function. Let be a circuit $C$ a circuit and $H$ a set of gates
in $C$ with unique labels. Then if $g$ is a gate in both $C$ and $C' :=
\op{merge-all}(C, H)$, and all of the children of $g$ in $C$ are in $H$, then no
two distinct children of $g$ in $C'$ are syntactically-equivalent. However, we
have no guarantee that $g$ will have unique labels in $C'$ as we have no
guarantee that $L'(g)$ is injective.

The now define the function $\op{make-injective}$ that maps a circuit and a
symmetric gate to an equivalent circuit containing all the same gates as the
input circuit but such that the specified gate now has injective labels.

\begin{definition}
  \label{def:make-injective}
  The function $\op{make-injective}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ and a gate $h \in G$ to the circuit
  $\op{make-injective}(C, h) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, defined as follows. Let $c = \max \{\vert L(g)^{-1}(h)\vert : g \in
  W(h, \cdot)\}$. If $c = 1$ then $C' := C$. If $c > 1$ then $C'$ is defined
  such that
  \begin{itemizens}
  \item $G' = G \uplus \{h_2, \ldots, h_{c-1}\}$,
  \item $\Omega' = \Omega$,
  \item For each $g \in G$ let $\Sigma' (g) = \Sigma(g)$, otherwise let
    $\Sigma'(g)$ be a single-input $\AND$-gate.
  \item $\Lambda'= \Lambda$
  \item For each $g \in G'$ if $g \in G \setminus W(h, \cdot)$ then $L'(g) =
    L(g)$. If $g \in W(h, \cdot)$ let $\{x_1, \ldots, x_k\} := L(g)^{-1}(h)$ and
    for each $x \in \ind(g)$ if $L(g)(x) \neq h$ then $L'(g)(x) = L(g)(x)$ else
    if $x = x_i \in L(g)^{-1}(h)$ then let $L'(g)(x) = h_i$.
  \end{itemizens}
\end{definition}

It can be shown that $\op{make-injective}$ can be computed by an algorithm
running in time polynomial in the size of the input circuit. Moreover, the input
and output circuits of this operation compute the same function.

We now define the function $\op{make-injective-all}$ that maps a circuit to an
equivalent circuit such that every symmetric gate now has injective labels.

\begin{definition}
  The function $\op{make-injective-all}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ to a circuit $\op{make-injective}(C) := C' :=
  \langle G', \Omega', \Sigma', \Lambda', L' \rangle$ defined as follows.

  Let $F$ be a function that maps an ordered circuit $C*$ to the circuit
  $\op{make-injective}(C*, h)$, where $h$ is the topologically first gate such
  that there exists a gate $g$ in $C*$ where $h$ is a child of $g$ and $\vert
  L*(g)^{-1}(h) \vert > 1$. Let $(C^0, C^1, \ldots)$ be a sequence of circuits
  where $C^0 := C$ and for $i > 1$, $C^i := F(C^{i-1})$. It can be shown that
  this sequence converges after at most $\vert C \vert$ many steps. Let $C'$ be
  the limit of this sequence.
\end{definition}

Since $\op{make-injective}$ can be computed in polynomial time, and the number
of iterations required to converge to the limit in the above definition is
bounded by the size of the circuit, it can be shown that
$\op{make-injective-all}$ can be computed in time polynomial in the size of the
input circuit. Furthermore, we note that $\op{make-injective-all}$ preserves
symmetry, rigidity and unique labels. Moreover, the input and output circuits
compute the same function.

We now define the function $\op{insert}$ that maps two circuits to a circuit
formed by inserting the gates of the first circuit into the second circuit.

\begin{definition}
  The function $\op{insert}$ maps a $(\mathbb{B}_1, \tau_1)$-circuit $C^1 :=
  \langle G_1, \Omega_1, \Sigma_1 , \Lambda_1, L_1 \rangle$ and a
  $(\mathbb{B}_2, \tau_2)$-circuit $C^2 := \langle G_2, \Omega_2, \Sigma_2 ,
  \Lambda_2, L_2 \rangle$ to a $(\mathbb{B}_1 \cup \mathbb{B}_2, \tau_1 \uplus
  \tau_2)$-circuit $\op{insert}(C^1, C^2) := C := \langle G, \Omega, \Sigma ,
  \Lambda, L \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G = G_1 \uplus G_2$,
  \item $\Omega = \Omega_2$,
  \item $\Sigma = \Sigma_1 \uplus \Sigma_2$,
  \item $\Lambda = \Lambda_1 \uplus \Lambda_2$, and
  \item $L = L_1 \uplus L_2$.
  \end{itemize}
\end{definition}

It can be shown that $\op{insert}$ can be be computed in time polynomial in the
size of the input circuits. Moreover, if the input circuits are symmetric then
the output circuit is symmetric.

We now define the function $\op{replace}$ that maps a circuit $C$ and a pair of
gates $(g_1, g_2)$ in $C$ to a circuit $C'$ formed by replacing $g_1$ with $g_2$
in $C$.

\begin{definition}
  The function $\op{replace}$ maps a circuit $C = \langle G, \Omega, \Sigma,
  \Lambda, L\rangle$ and a pair of gates $(g_1, g_2)$ in $C$ to a circuit
  $\op{replace}(C, g_1, g_2) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{g_1\}$,
  \item $\Omega'$ is an function from the domain of $\Omega$ to $G'$ such that
    for each $\vec{a} \in \dom(\Omega)$ if $\Omega(\vec{a}) = g_1$ then
    $\Omega'(\vec{a}) = g_2$ and otherwise $\Omega'(\vec{a}) = \Omega(\vec{a})$.
  \item $\Sigma' = \restr{\Sigma}{G'}$
  \item $\Lambda' = \restr{\Lambda}{G'}$
  \item For each $g \in G'$ and each $x \in \ind(g)$ if $L(g)(x) = g_1$ then
    $L'(g)(x) = g_2$ and if not then $L'(g)(x) = L(g)(x)$.
  \end{itemize}
\end{definition}

It can be shown that the function $\op{replace}$ can be computed in time
polynomial in the size of the input circuit.

We now define the function $\op{tag}$ that maps a circuit, a relation symbol, a
gate in that circuit, and a tuple to a circuit computing the same function as
the input circuit but with an additional gadget, constructed using the gates
labelled by the given relation symbol and tuple, marking the designated gate.
The intuition is that this marking helps to distinguish a gate, and is used as a
step to ensure that a circuit has unique labels.

\begin{definition}
  The function $\op{tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle G,
  \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a gate $g \in G$, and a tuple $\vec{a} \in [n]^k$ for some $k$ to a
  circuit $\op{tag}(C, R, g, \vec{a}) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$, such that $G' = G \uplus \{\land_g,
  \land_{g'}, \land_1, \ldots , \land_k\}$, $\Omega' = \Omega$, and $\Lambda' =
  \Lambda$. For each $g \in G$ $\Sigma'(g) = \Sigma(g)$. For each $g \in
  \{\land_0, \land_1, \ldots , \land_k \}$, $\Sigma(g)$ is an $\AND$-gate that
  takes in two inputs. $\Sigma(\land_g)$ is an $\AND$-gate that takes in a
  single input, $g$ is the lone input to $\land_g$, and $\land_0$ has as input
  $\land_g$ and $\land_1$. For each $i \in [k-1]$ the inputs of $\land_i$ are
  $\land_{i+1}$ and the gate $g_i \in G'$ such that $\Sigma(g_i) = R$ and
  $\Lambda^{-1}(g_i) = \vec{a}_i$, where $\vec{a}_i$ is the $k$-tuple
  $(\vec{a}(i), \ldots, \vec{a}(i))$. The inputs of $\land_k$ are the constant
  gate $1$ and the gate $g_k$ such that $\Sigma(g) = R$ and $\Lambda^{-1}(g_k) =
  \vec{a}_k$. For each gate $h \in G \setminus \{g\}$ and $x \in \ind(h)$, if
  $L(h)(x) = g$ then $L'(h)(x) = \land_0$, otherwise $L'(h)(x) = L(h)(x)$.
\end{definition}

It can be shown that $\op{tag}$ can be computed in time polynomial in the size
of its input. The input and output circuits compute the same function. Moreover,
if the input circuit has unique labels then the output circuit will have unique
labels. If the input relation symbol is obvious from the context we omit it when
invoking $\op{tag}$.

\begin{definition}
  The function $\op{tag-all}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a set of gates $H \subseteq G$, and $T := (\vec{a}_h)_{h \in H}
  \subseteq [n]^{k}$ a sequence of tuples indexed by $H$ for some fixed $k$, to
  a circuit $\op{tag-all}(C, R, H, T) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$ defined as follows.

  Suppose there is a linear order on $H$, and write $H = \{h_1, \ldots, h_t\}$.
  Let $C_0 := C$ and for all $i \in [t]$ let $C_i := \op{tag}(C_{i-1}, R, h_i,
  T(h_i))$. Then $C' = C_{t}$.
\end{definition}

It is easy to see that, since $\op{tag}$ can be computed in time polynomial in
the combined size of its inputs, $\op{tag-all}$ can also be computed in time
polynomial in the combined size of its inputs.

We now define the function $\op{compose}$ that maps a circuit and a sequence of
circuits and to a circuit formed by replacing the input gates of the designated
circuit with the output gates of the circuits in the sequence.

\begin{definition}
  The function $\op{compose}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation sybmols $\tau_R
  := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence of
  circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose}(C,
  \mathcal{C}, \tau_R) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$. Note that all circuits take in structures of size $n$. The circuit
  $C'$ is defined as follows.
  
  Let ${C^0}' := \langle G_0', \Omega_0', \Sigma_0', \Lambda_0', L_0' \rangle :=
  C$, and let $i \in [t]$. Let $D^{i-1}:= \op{insert} (C^i, {C^{i-1}}')$ and
  $G^{i-1}_{R_i}$ be the set of all relational gates in $D^{i-1}$ labelled by
  the relational symbol in $R_i$. Let ${C^{i-1}}' := \langle G_i', \Omega_i',
  \Sigma_i', \Lambda_i', L_i' \rangle$ be the circuit formed from $D^{i-1}$ by
  replacing each gate in $g \in G^{i-1}_{R_i}$ with the gate
  $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ (by repeated calls to the
  $\op{replace}$ function). Let $C' = {C^{t}}'$.
\end{definition}

It can be shown that $\op{compose}$ can be computed in time polynomial in the
sum of the sizes of the input circuits. We also note that the size of $C'$ is
less than or equal to the sum of the sizes of the input circuits. Moreover, if
the input circuits are all symmetric then the output circuit will be symmetric.
Also, for an input tuple $(C, \mathcal{C}, \tau_R)$, we have that if $C$ has
symmetric gates and transparent, and all the circuits in $\mathcal{C}$ are
transparent, then $C' := \op{compose}(C, \mathcal{C}, \tau_R)$ is transparent.
If $C$ contains a non-symmetric gates then, as the output gates of the circuits
in $\mathcal{C}$ are no longer labelled as output gates in $C'$, it may be that
some of these gates are syntactically-equivalent in $C'$, resulting in $C'$ not
being transparent.

In certain contexts we are interested composing gates such that if the input
circuits are transparent (resp. have unique labels) then the output circuits
will be transparent (resp. have unique labels). In this case, while composing
the circuits we apply the $\op{tag}$ function to the output gates of the
circuits in the input sequence of circuits. We now define the function
$\op{compose-and-tag}$ that implements this operation.

\begin{definition}
  The function $\op{compose-and-tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
  \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation symbols
  $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence
  of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose-and-tag}(C,
  \mathcal{C}, \tau_R, R) := C'$. The circuit $C'$ is defined as follows. Note
  that all circuits take in structures of size $n$.
  
  Let $D^0 := \op{compose}(C, \mathcal{C}, \tau_R)$. For each $i \in [t]$, let
  $D^{i} := \op{tag-all}(D^{i-1}, R, \img(\Omega^{-1}_i), \Omega^{-1}_i)$. Let
  $C' := D^t$.
\end{definition}

It is easy to see that $\op{compose-and-tag}$ can be computed in time polynomial
in the sun of the sizes of the input circuits. We also have that if the input
circuits are symmetric then the output circuits are symmetric. Furthermore, if
the input sequences of circuits and relations are both singletons, then if the
input circuits are all transparent (resp. have unique labels) then the output
circuit is transparent (resp. have unique labels). We also note that the output
circuit

\subsection{Translating FPR to Symmetric Matrix Circuits}
In this subsection we translate $\FPR$-formulas into families of transparent
rank-circuits. In particular, we now show that for $\theta(\vec{x}) \in
\FPR[\tau]$ there exists a $P$-uniform family of symmetric rank-circuits
$(C_n)_{n \in \nats}$ such that the query computed by $(C_n)_{n \in \nats}$ is
equal to the query defined by $\theta (\vec{x})$.

\begin{thm}
  For any relational vocabulary $\tau$ and each $\theta(\vec{x}) \in \FPR[\tau]$
  there is a map $n \mapsto C_n$, where $C_n$ is a transparent symmetric
  rank-circuit, and is computable in time polynomial in $n$. The family of
  circuits $(C_n)_{n \in \nats}$ defined by this mapping computes the same query
  as the one defined by $\theta(\vec{x})$.
  \label{thm:translating-formulas-to-circuits}
\end{thm}

\begin{proof}
  We say that a circuit $C$ \emph{translates} a formula $\psi(\vec{x})$ for $n
  \in \nats$ if $C$ is a transparent symmetric rank-circuit of order $n$ and $C$
  computes the query defined by $\psi(\vec{x})$ on structures of size $n$. We
  say a family of circuits $(C_n)_{n \in \nats}$ \emph{translates} a formula
  $\psi (\vec{x})$ if $(C_n)_{n \in \nats}$ is $\PT$-uniform and for all $n \in
  \nats$, $C_n$ translates $\psi(\vec{x})$ for $n$.

  We have from Anderson and Dawar~\cite{AndersonD17} that for every formula
  $\phi(\vec{x}) \in \FPC[\tau]$ there is a $\PT$-uniform family of symmetric
  circuits $(C^{\phi}_n)_{n \in \nats}$ with unique labels and symmetric gates
  that translates $\phi(\vec{x})$.
  
  Let $\theta(\vec{x}) \in \FPR[\tau]$ and $t := \width (\theta)$. We begin by
  showing that there exists a $P$-uniform family of formulas
  $(\theta(\vec{x}))_{n \in \nats}$ such that for each $n \in \nats$, we have
  $\theta_n(\vec{x}) \in \FOrk[\tau]$, $\width(\theta_n) \leq 4 t$, and
  $\theta_n(\vec{x})$ is equivalent to $\theta(\vec{x})$ on structures of size
  $n$. This result follows from two observations.

  First, using the translation in~\cite{Dawar09logicswith}, we have that for any
  $\phi(\vec{x}) \in \FPR[\tau]$ of the form $\lfp{V, \vec{y}}{\psi(\vec{x},
    \vec{y}, V)}(\vec{x})$ , there is a mapping $n \mapsto \phi_n$, computable
  in time polynomial in both $n$ and the size of $\phi(\vec{x})$ such that for
  all $n \in \nats$, we have $\phi_n(\vec{x}) \in \FOR[\tau]$, $\width (\phi_n)
  \leq 2 \cdot \width (\phi)$, and $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are
  equivalent on structures of size $n$.

  Second, using the translation in~\cite{libkin2004elements}, we have that if
  $\phi (\vec{x}) \in \FOR[\tau]$ is of the form $\rank (\vec{y}\vec{\mu} \leq
  \vec{t}, \vec{z}\vec{\nu} \leq \vec{s}, \pi \leq r) . \psi (\vec{y}\vec{\mu},
  \vec{z} \vec{\nu})$, then there is a mapping $n \mapsto \phi_n$ computable in
  time polynomial in both $n$ and the size of $\phi(\vec{x})$ such that for all
  $n \in \nats$, $\phi_n(\vec{x}) \in \FOrk[\tau]$, $\width(\phi_n) \leq 2 \cdot
  \width(\phi)$, and $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are equivalent on
  structures of size $n$.

  We thus derive the required $\PT$-uniform family $(\theta_n(\vec{x}))_{n \in
    \nats}$ by applying the first translation and then the second.

  Fix $n \in \nats$. We recursively define a function $T_n$ that maps $\psi
  (\vec{y})$, a sub-formula of $\theta_n(\vec{x})$, to a circuit $C^{\psi}_n$,
  where $C^{\psi}_n$ translates $\psi(\vec{y})$ at $n$. We then have that for
  all $n \in \nats$, $T_n(\theta_n(\vec{x}))$ translates $\theta_n$ (and hence
  $\theta$) at $n$.

  We first consider the base case. Suppose $\psi(\vec{y})$ is an atomic formula.
  Then $\psi(\vec{y}) \in \FPC[\tau]$, and so, using the translation defined by
  Anderson and Dawar~\cite{AndersonD17}, there exists a family of circuits
  $(C^{\psi}_n)_{n \in \nats}$ that translates $\psi(\vec{y})$. Let
  $T_n(\psi(\vec{y})) := C^{\psi}_n$.

  We now consider the conjunctive case. Suppose $\psi(\vec{y})$ is a sub-formula
  of $\theta_n(\vec{x})$ such that $\psi (\vec{y}) = \phi_1(\vec{y}) \land
  \phi_2(\vec{y})$. Let $R_{\phi_1}$ and $R_{\phi_2}$ be two $\vert \vec{y}
  \vert$-ary relation symbols not in $\tau$ and let $\psi' (\vec{y}) :=
  R_{\phi_1}(\vec{y}) \land R_{\phi_2}(\vec{y})$. Then $\psi'(\vec{y}) \in
  \FPC[\tau]$ and so, using the translation defined by Anderson and Dawar, there
  exists a circuit family $(C^{\psi'}_n)_{n \in \nats}$ that translates
  $\psi'(\vec{y})$. Let $T_n(\psi (\vec{y})) := \op{compose}(C^{\psi'}_n, (
  T_n(\phi_1(\vec{y})), T_n(\phi_2(\vec{y}))), (R_{\phi_1}, R_{\phi_2}))$. We
  note that $T_n(\psi(\vec{y}))$ translates $\psi (\vec{y})$ at $n$ if
  $T_n(\phi_1 (\vec{y}))$ and $T_n(\phi_2(\vec{y}))$ translate $\phi_1(\vec{y})$
  and $\phi_2(\vec{y})$ at $n$, respectively.

  The approach used in the conjunctive case can be summarised as follows. Given
  a sub-formula $\psi (\vec{y})$, we construct an auxiliary formula
  $\psi'(\vec{y})$ in which all the sub-formulas of $\psi(\vec{y})$ are replaced
  with relation symbols. We then construct a circuit $C^{\psi'}$ that translates
  $\psi'(\vec{y})$ at $n$ using the translation defined by Anderson and Dawar.
  Finally, we recursively construct circuits that translate the sub-formulas of
  $\psi(\vec{y})$, and compose these circuits with $C^{\psi'}$.
  
  This approach can be used in order to handle every case with the exception of
  rank. In other words, we can use a similar approach to define
  $T_n(\psi(\vec{y}))$ where $\psi(\vec{y})$ is a sub-formula of
  $\theta_n(\vec{x})$ of the form $\phi_1(\vec{y}) \lor \phi_2(\vec{y})$, $\neg
  \phi(\vec{y})$, $\forall z. \phi (\vec{y}, z)$, or $\exists z. \phi (\vec{y},
  z)$.

  We now handle the rank case. The approach is quite similar, except in this
  case we cannot use the translation defined by Anderson and Dawar in order to
  translate the auxiliary formula, and so must define this translation
  explicitly. Moreover, rather than just composing the circuits, we also add a
  small gadget in order to ensure the resultant circuit is transparent.
  
  Suppose $\psi(\vec{z}, \vec{w}, \vec{y})$ is a sub-formula of
  $\theta_n(\vec{x})$ such that $\psi (\vec{y}) = \rank^{\leq r}_p \vec{z},
  \vec{w} .\phi(\vec{z}, \vec{w}, \vec{y})$, for some $p, r \in \nats$ and $p$
  prime. Let $k:= \vert \vec{y} \vert$, $k_1 : = \vert \vec{z} \vert$ and $k_2
  := \vert \vec{w} \vert$. Let $R_\phi$ be a $(k_1 + k_2 + k)$-ary relation
  symbol not in $\tau$. Let $\psi'(\vec{y}) := \rank^{\leq r}_p\vec{z}, \vec{w}.
  R_{\phi} (\vec{z}, \vec{w}, \vec{y})$. Let $G_{\text{out}} := \{g_{\vec{c}} :
  \vec{c} \in [n]^k\}$ and $G_{\text{in}} : = \{ g_{\vec{a}, \vec{b}, \vec{c}} :
  \vec{a} \in [n]^{k_1}, \vec{b} \in [n]^{k_2}, \vec{c} \in [n]^{k}\}$. Let
  $C^{\psi'}_n:= \langle G^{\psi'}, \Omega^{psi'}, \Sigma^{\psi'},
  \Lambda^{\psi'}, L^{\psi'}\rangle$ be a $(\mathbb{B}_{\rank}, \{ R_{\phi}
  \})$-circuit such that
  \begin{itemizens}
  \item $G^{\psi'} = G_{\text{out}} \cup G_{\text{in}}$,
  \item $\Omega^{\psi'}$ be an injection from $[n]^k$ to $G^{\psi'}$ defined by
    $\Omega^{\psi'}(\vec{c}) = g_{\vec{c}}$ for all $\vec{c} \in [n]^k$,
  \item $\Sigma^{\psi'} (g) = \rank^r_p$ if $g \in G_{\text{out}}$ and
    $\Sigma^{\psi'}(g) = R_\phi$ if $g \in G_{\text{in}}$,
  \item for each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$,
    $\Lambda^{\psi'} (\vec{a}, \vec{b}, \vec{c}) = g_{\vec{a}, \vec{b},
      \vec{c}}$, and
  \item for each gate $g_{\vec{c}} \in G_{\text{out}}$, $L(g_{\vec{c}}):
    [n]^{k_1} \times [n]^{k_2} \rightarrow G^{\psi'}$ is defined by
    $L(g_{\vec{c}})(\vec{a}, \vec{b}) := g_{\vec{a}, \vec{b}, \vec{c}}$ for each
    $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.
  \end{itemizens}

  We note that $C^{\psi'}_n$ translates $\psi (\vec{y})$ at $n$. Let $R$ be a
  relation symbol in $\tau$. Let
  \begin{align*} T_n(\psi(\vec{y})) := \op{compose-and-tag}(C^{\psi'}_n,
    (T_n(\phi(\vec{z}, \vec{w}, \vec{y}))), (R_\phi), R).
  \end{align*}

  We recall that $\op{compose-and-tag}$ combines circuits in a similar way to
  $\op{compose}$ except that it also adds a set of gadgets to the circuit
  ensuring that no two child gates of an output gate are
  syntactically-equivalent. We thus have that $T_n(\psi (\vec{y}))$ is
  transparent if $T_n(\phi (\vec{z}, \vec{w},\vec{y}))$ is transparent, and
  $T_n(\psi(\vec{y}))$ translates $\psi (\vec{y})$ at $n$ if $T_n(\phi (\vec{z},
  \vec{w},\vec{y}))$ translates $\phi(\vec{z}, \vec{w}, \vec{y})$ at $n$.

  We have completed our definition of $T_n$ and shown, by induction on the
  structure of $\theta_n(\vec{x})$, that for each $\psi (\vec{y})$ a sub-formula
  of $\theta_n(\vec{x})$, $T_n(\psi(\vec{y}))$ translates $\psi(\vec{y})$ at
  $n$.

  The above definition can be used to define a recursive algorithm computing the
  function $n \mapsto T_n (\theta_n(\vec{x}))$. We note that, since
  $\width(\theta_n) \leq 4 t$ for all $n \in \nats$, there are only a finite
  number of cases that need to be considered at each recursive step in this
  algorithm. This fact can be used to show that there exists a polynomial bound
  on the running time of the algorithm that depends only on $n$ and the
  structure of $\theta(\vec{x})$. As such, we have that $(T_n (\theta_n))_{n \in
    \nats}$ translates $\theta(\vec{x})$, and the result follows.
\end{proof}

\bibliography{../references.bib}
% \ifcsdef{mainfile}{}{\bibliography{../references.bib}}
\end{document}
