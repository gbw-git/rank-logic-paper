\documentclass[../paper.tex]{subfiles}
\begin{document}
% In this section we first introduce a number of useful polynomial-time
% computable functions which define transformations on circuits. In the second
% subsection we use these functions to define a transformation that takes
% $\FPR$-formulas to equivalent families of transparent symmetric rank-circuits.

% \subsection{Algorithms for Circuits}
% In order to simplify the presentation of the translation between $P$-uniform
% families of circuits and formulas of $\FPR$, as well as the proofs of other
% results (see Lemma~\ref{lem:transparent-unique}), we define a number of
% often-used polynomial-time computable circuit transformations.

% We first define the function $\op{merge}$, which maps a circuit and a set of
% syntactically-equivalent gates to a circuit formed by combining those gates
% into a single gate.

% \begin{definition}
%   Let $C := \langle G, \Omega, \Sigma , \Lambda, L \rangle$ be a circuit and
%   $H := \{h_1, \ldots, h_p\}$ be a set of syntactically equivalent gates. We
%   let $\op{merge}(C, H) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
%   \rangle$, where
%   \begin{itemize}
%     \setlength\itemsep{0mm}
%   \item $G' = G \setminus \{h_2, \ldots, h_p\}$,
%   \item $\Omega' = \Omega$,
%   \item $\Sigma' = \restr{\Sigma}{G'}$,
%   \item $\Lambda' = \Lambda$, and
%   \item For all $g \in G'$ and $x \in Ind(g)$ if $L(g) (x) \in H$ then
%     $L'(g)(x) = h_1$ and if $L(g)(x) \notin H$ then $L'(g)(x) = L(g)(x)$.
%   \end{itemize}
% \end{definition}

% It can be shown that $\op{merge}$ can be computed in time polynomial in the
% size of the input circuit. We note that the input and output circuits compute
% the same function. Moreover, if the input circuit is symmetric (resp. has
% unique labels, is transparent) then the output circuit will also be symmetric
% (resp. have unique labels, transparent).

% We now define the function $\op{merge-all}$ which maps a circuit and a set of
% gates to a new circuit formed by applying $\op{merge}$ to the
% syntactic-equivalence classes of the set of gates.

% \begin{definition}
%   \label{def:merge-all}
%   The function $\op{merge-all}$ maps a circuit $C$ and a set of gates $H$ to a
%   circuit $\op{merge-all}(C, H) := C'$, where $C'$ is defined as follows. Let
%   $H_1, \ldots, H_p$ be the syntactic equivalence classes of $H$, and let $C'$
%   be defined from $C$ by successively applying $\op{merge}$ to each of these
%   equivalence classes.
% \end{definition}

% We can compute $\op{merge-all}$ using the following algorithm. Let $(C, H)$ be
% a tuple in the domain of $\op{merge-all}$. We assume a reasonable encoding of
% the circuit, and note that any such encoding induces a linear order on the
% structure. Let $H_1, \ldots, H_p$ be the syntactic-equivalence classes of $H$
% linearly ordered such that for all $i, j \in [p]$ if $i \leq j$ the height of
% the gates in $H_i$ is less than or equal to the height of the gates in $H_j$.
% Let $C'$ be the result of successively executing the algorithm for
% $\op{merge}$ on each such equivalence class in order.

% It is worth noting that for an input tuple $(C, H)$, if follows from
% Lemma~\cite{lem:unique-labels-syntactic-equiv} that if $H$ has unique labels
% then the syntactic-equivalence relation on $H$ can be computed in time
% polynomial in the size of $C$. Thus, if each gate in $H$ has unique labels, it
% can be shown that $\op{merge-all}$ can be computed in time polynomial in the
% size of the input circuit.

% As in the case of $\op{merge}$, the function $\op{merge-all}$ preserves
% symmetry, unique labels and the ensures that the input and output circuits
% compute the same function. Let be a circuit $C$ a circuit and $H$ a set of
% gates in $C$ with unique labels. Then if $g$ is a gate in both $C$ and $C' :=
% \op{merge-all}(C, H)$, and all of the children of $g$ in $C$ are in $H$, then
% no two distinct children of $g$ in $C'$ are syntactically-equivalent. However,
% we have no guarantee that $g$ will have unique labels in $C'$ as we have no
% guarantee that $L'(g)$ is injective.

% The now define the function $\op{make-injective}$ that maps a circuit and a
% symmetric gate to an equivalent circuit containing all the same gates as the
% input circuit but such that the specified gate now has injective labels.

% \begin{definition}
%   \label{def:make-injective}
%   The function $\op{make-injective}$ maps a circuit $C := \langle G, \Omega,
%   \Sigma , \Lambda, L \rangle$ and a gate $h \in G$ to the circuit
%   $\op{make-injective}(C, h) := C' := \langle G', \Omega', \Sigma', \Lambda',
%   L' \rangle$, defined as follows. Let $c = \max \{\vert L(g)^{-1}(h)\vert : g
%   \in W(h, \cdot)\}$. If $c = 1$ then $C' := C$. If $c > 1$ then $C'$ is
%   defined such that
%   \begin{itemizens}
%   \item $G' = G \uplus \{h_2, \ldots, h_{c-1}\}$,
%   \item $\Omega' = \Omega$,
%   \item For each $g \in G$ let $\Sigma' (g) = \Sigma(g)$, otherwise let
%     $\Sigma'(g)$ be a single-input $\AND$-gate.
%   \item $\Lambda'= \Lambda$
%   \item For each $g \in G'$ if $g \in G \setminus W(h, \cdot)$ then $L'(g) =
%     L(g)$. If $g \in W(h, \cdot)$ let $\{x_1, \ldots, x_k\} := L(g)^{-1}(h)$
%     and for each $x \in \ind(g)$ if $L(g)(x) \neq h$ then $L'(g)(x) = L(g)(x)$
%     else if $x = x_i \in L(g)^{-1}(h)$ then let $L'(g)(x) = h_i$.
%   \end{itemizens}
% \end{definition}

% It can be shown that $\op{make-injective}$ can be computed by an algorithm
% running in time polynomial in the size of the input circuit. Moreover, the
% input and output circuits of this operation compute the same function.

% We now define the function $\op{make-injective-all}$ that maps a circuit to an
% equivalent circuit such that every symmetric gate now has injective labels.

% \begin{definition}
%   The function $\op{make-injective-all}$ maps a circuit $C := \langle G,
%   \Omega, \Sigma , \Lambda, L \rangle$ to a circuit $\op{make-injective}(C) :=
%   C' := \langle G', \Omega', \Sigma', \Lambda', L' \rangle$ defined as
%   follows.

%   Let $F$ be a function that maps an ordered circuit $C*$ to the circuit
%   $\op{make-injective}(C*, h)$, where $h$ is the topologically first gate such
%   that there exists a gate $g$ in $C*$ where $h$ is a child of $g$ and $\vert
%   L*(g)^{-1}(h) \vert > 1$. Let $(C^0, C^1, \ldots)$ be a sequence of circuits
%   where $C^0 := C$ and for $i > 1$, $C^i := F(C^{i-1})$. It can be shown that
%   this sequence converges after at most $\vert C \vert$ many steps. Let $C'$
%   be the limit of this sequence.
% \end{definition}

% Since $\op{make-injective}$ can be computed in polynomial time, and the number
% of iterations required to converge to the limit in the above definition is
% bounded by the size of the circuit, it can be shown that
% $\op{make-injective-all}$ can be computed in time polynomial in the size of
% the input circuit. Furthermore, we note that $\op{make-injective-all}$
% preserves symmetry, rigidity and unique labels. Moreover, the input and output
% circuits compute the same function.

% We now define the function $\op{insert}$ that maps two circuits to a circuit
% formed by inserting the gates of the first circuit into the second circuit.

% \begin{definition}
%   The function $\op{insert}$ maps a $(\mathbb{B}_1, \tau_1)$-circuit $C^1 :=
%   \langle G_1, \Omega_1, \Sigma_1 , \Lambda_1, L_1 \rangle$ and a
%   $(\mathbb{B}_2, \tau_2)$-circuit $C^2 := \langle G_2, \Omega_2, \Sigma_2 ,
%   \Lambda_2, L_2 \rangle$ to a $(\mathbb{B}_1 \cup \mathbb{B}_2, \tau_1 \uplus
%   \tau_2)$-circuit $\op{insert}(C^1, C^2) := C := \langle G, \Omega, \Sigma ,
%   \Lambda, L \rangle$, where
%   \begin{itemize}
%     \setlength\itemsep{0mm}
%   \item $G = G_1 \uplus G_2$,
%   \item $\Omega = \Omega_2$,
%   \item $\Sigma = \Sigma_1 \uplus \Sigma_2$,
%   \item $\Lambda = \Lambda_1 \uplus \Lambda_2$, and
%   \item $L = L_1 \uplus L_2$.
%   \end{itemize}
% \end{definition}

% It can be shown that $\op{insert}$ can be be computed in time polynomial in
% the size of the input circuits. Moreover, if the input circuits are symmetric
% then the output circuit is symmetric.

% We now define the function $\op{replace}$ that maps a circuit $C$ and a pair
% of gates $(g_1, g_2)$ in $C$ to a circuit $C'$ formed by replacing $g_1$ with
% $g_2$ in $C$.

% \begin{definition}
%   The function $\op{replace}$ maps a circuit $C = \langle G, \Omega, \Sigma,
%   \Lambda, L\rangle$ and a pair of gates $(g_1, g_2)$ in $C$ to a circuit
%   $\op{replace}(C, g_1, g_2) := C' := \langle G', \Omega', \Sigma', \Lambda',
%   L' \rangle$, where
%   \begin{itemize}
%     \setlength\itemsep{0mm}
%   \item $G' = G \setminus \{g_1\}$,
%   \item $\Omega'$ is an function from the domain of $\Omega$ to $G'$ such that
%     for each $\vec{a} \in \dom(\Omega)$ if $\Omega(\vec{a}) = g_1$ then
%     $\Omega'(\vec{a}) = g_2$ and otherwise $\Omega'(\vec{a}) =
%     \Omega(\vec{a})$.
%   \item $\Sigma' = \restr{\Sigma}{G'}$
%   \item $\Lambda' = \restr{\Lambda}{G'}$
%   \item For each $g \in G'$ and each $x \in \ind(g)$ if $L(g)(x) = g_1$ then
%     $L'(g)(x) = g_2$ and if not then $L'(g)(x) = L(g)(x)$.
%   \end{itemize}
% \end{definition}

% It can be shown that the function $\op{replace}$ can be computed in time
% polynomial in the size of the input circuit.

% We now define the function $\op{tag}$ that maps a circuit, a relation symbol,
% a gate in that circuit, and a tuple to a circuit computing the same function
% as the input circuit but with an additional gadget, constructed using the
% gates labelled by the given relation symbol and tuple, marking the designated
% gate. The intuition is that this marking helps to distinguish a gate, and is
% used as a step to ensure that a circuit has unique labels.

% \begin{definition}
%   The function $\op{tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle G,
%   \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
%   \tau$, a gate $g \in G$, and a tuple $\vec{a} \in [n]^k$ for some $k$ to a
%   circuit $\op{tag}(C, R, g, \vec{a}) := C' := \langle G', \Omega', \Sigma',
%   \Lambda', L'\rangle$ of order $n$, such that $G' = G \uplus \{\land_g,
%   \land_{g'}, \land_1, \ldots , \land_k\}$, $\Omega' = \Omega$, and $\Lambda'
%   = \Lambda$. For each $g \in G$ $\Sigma'(g) = \Sigma(g)$. For each $g \in
%   \{\land_0, \land_1, \ldots , \land_k \}$, $\Sigma(g)$ is an $\AND$-gate that
%   takes in two inputs. $\Sigma(\land_g)$ is an $\AND$-gate that takes in a
%   single input, $g$ is the lone input to $\land_g$, and $\land_0$ has as input
%   $\land_g$ and $\land_1$. For each $i \in [k-1]$ the inputs of $\land_i$ are
%   $\land_{i+1}$ and the gate $g_i \in G'$ such that $\Sigma(g_i) = R$ and
%   $\Lambda^{-1}(g_i) = \vec{a}_i$, where $\vec{a}_i$ is the $k$-tuple
%   $(\vec{a}(i), \ldots, \vec{a}(i))$. The inputs of $\land_k$ are the constant
%   gate $1$ and the gate $g_k$ such that $\Sigma(g) = R$ and $\Lambda^{-1}(g_k)
%   = \vec{a}_k$. For each gate $h \in G \setminus \{g\}$ and $x \in \ind(h)$,
%   if $L(h)(x) = g$ then $L'(h)(x) = \land_0$, otherwise $L'(h)(x) = L(h)(x)$.
% \end{definition}

% It can be shown that $\op{tag}$ can be computed in time polynomial in the size
% of its input. The input and output circuits compute the same function.
% Moreover, if the input circuit has unique labels then the output circuit will
% have unique labels. If the input relation symbol is obvious from the context
% we omit it when invoking $\op{tag}$.

% \begin{definition}
%   The function $\op{tag-all}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
%   \langle G, \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation
%   symbol $R \in \tau$, a set of gates $H \subseteq G$, and $T :=
%   (\vec{a}_h)_{h \in H} \subseteq [n]^{k}$ a sequence of tuples indexed by $H$
%   for some fixed $k$, to a circuit $\op{tag-all}(C, R, H, T) := C' := \langle
%   G', \Omega', \Sigma', \Lambda', L'\rangle$ of order $n$ defined as follows.

%   Suppose there is a linear order on $H$, and write $H = \{h_1, \ldots,
%   h_t\}$. Let $C_0 := C$ and for all $i \in [t]$ let $C_i := \op{tag}(C_{i-1},
%   R, h_i, T(h_i))$. Then $C' = C_{t}$.
% \end{definition}

% It is easy to see that, since $\op{tag}$ can be computed in time polynomial in
% the combined size of its inputs, $\op{tag-all}$ can also be computed in time
% polynomial in the combined size of its inputs.

% We now define the function $\op{compose}$ that maps a circuit and a sequence
% of circuits and to a circuit formed by replacing the input gates of the
% designated circuit with the output gates of the circuits in the sequence.

% \begin{definition}
%   The function $\op{compose}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
%   \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation
%   sybmols $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a
%   sequence of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i
%   \in [t]$, $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is
%   a $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and
%   $C^i$ computes a query of arity $\arty(R_i)$ to a circuit $\op{compose}(C,
%   \mathcal{C}, \tau_R) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
%   \rangle$. Note that all circuits take in structures of size $n$. The circuit
%   $C'$ is defined as follows.
  
%   Let ${C^0}' := \langle G_0', \Omega_0', \Sigma_0', \Lambda_0', L_0' \rangle
%   := C$, and let $i \in [t]$. Let $D^{i-1}:= \op{insert} (C^i, {C^{i-1}}')$
%   and $G^{i-1}_{R_i}$ be the set of all relational gates in $D^{i-1}$ labelled
%   by the relational symbol in $R_i$. Let ${C^{i-1}}' := \langle G_i',
%   \Omega_i', \Sigma_i', \Lambda_i', L_i' \rangle$ be the circuit formed from
%   $D^{i-1}$ by replacing each gate in $g \in G^{i-1}_{R_i}$ with the gate
%   $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ (by repeated calls to the
%   $\op{replace}$ function). Let $C' = {C^{t}}'$.
% \end{definition}

% It can be shown that $\op{compose}$ can be computed in time polynomial in the
% sum of the sizes of the input circuits. We also note that the size of $C'$ is
% less than or equal to the sum of the sizes of the input circuits. Moreover, if
% the input circuits are all symmetric then the output circuit will be
% symmetric. Also, for an input tuple $(C, \mathcal{C}, \tau_R)$, we have that
% if $C$ has symmetric gates and transparent, and all the circuits in
% $\mathcal{C}$ are transparent, then $C' := \op{compose}(C, \mathcal{C},
% \tau_R)$ is transparent. If $C$ contains a non-symmetric gates then, as the
% output gates of the circuits in $\mathcal{C}$ are no longer labelled as output
% gates in $C'$, it may be that some of these gates are syntactically-equivalent
% in $C'$, resulting in $C'$ not being transparent.

% In certain contexts we are interested composing gates such that if the input
% circuits are transparent (resp. have unique labels) then the output circuits
% will be transparent (resp. have unique labels). In this case, while composing
% the circuits we apply the $\op{tag}$ function to the output gates of the
% circuits in the input sequence of circuits. We now define the function
% $\op{compose-and-tag}$ that implements this operation.

% \begin{definition}
%   The function $\op{compose-and-tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C
%   := \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation
%   symbols $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a
%   sequence of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i
%   \in [t]$, $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is
%   a $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and
%   $C^i$ computes a query of arity $\arty(R_i)$ to a circuit
%   $\op{compose-and-tag}(C, \mathcal{C}, \tau_R, R) := C'$. The circuit $C'$ is
%   defined as follows. Note that all circuits take in structures of size $n$.
  
%   Let $D^0 := \op{compose}(C, \mathcal{C}, \tau_R)$. For each $i \in [t]$, let
%   $D^{i} := \op{tag-all}(D^{i-1}, R, \img(\Omega^{-1}_i), \Omega^{-1}_i)$. Let
%   $C' := D^t$.
% \end{definition}

% It is easy to see that $\op{compose-and-tag}$ can be computed in time
% polynomial in the sun of the sizes of the input circuits. We also have that if
% the input circuits are symmetric then the output circuits are symmetric.
% Furthermore, if the input sequences of circuits and relations are both
% singletons, then if the input circuits are all transparent (resp. have unique
% labels) then the output circuit is transparent (resp. have unique labels). We
% also note that the output circuit

% \subsection{Translating FPR to Symmetric Matrix Circuits}
% In this subsection we translate $\FPR$-formulas into families of transparent
% rank-circuits. In particular, we now show that for $\theta(\vec{x}) \in
% \FPR[\tau]$ there exists a $P$-uniform family of symmetric rank-circuits
% $(C_n)_{n \in \nats}$ such that the query computed by $(C_n)_{n \in \nats}$ is
% equal to the query defined by $\theta (\vec{x})$.

In this section we construct for every formula of $\FPR$ an equivalent
$\PT$-uniform family of transparent symmetric rank-circuits. We say that a
circuit $C$ \emph{translates} a formula $\psi(\vec{x})$ for $n \in \nats$ if $C$
is a transparent symmetric rank-circuit of order $n$, $C$ is defined over the
same vocabulary as $\psi$, and $C$ computes the query defined by $\psi(\vec{x})$
on structures of size $n$. We say a family of circuits $(C_n)_{n \in \nats}$
\emph{translates} a formula $\psi (\vec{x})$ if $(C_n)_{n \in \nats}$ is
$\PT$-uniform and for all $n \in \nats$, $C_n$ translates $\psi(\vec{x})$ for
$n$.

We first show that for every $\FOrk$-formula $\theta(\vec{x})$ and $n \in \nats$
there exists a circuit $C$ that translates $\theta(\vec{x})$ for $n$. The
circuit $C$ contains a gate for each sub-formula $\psi$ of $\theta$ and each
compatible assignment $\alpha$ to the free variables of $\psi$. We call this
gate $g_{\psi[\alpha]}$. We label $g_{\psi[\alpha]}$ with an element of the
basis appropriate to the operator at the head of the formula $\psi$ and wire up
the circuit such that the children of $g_{\psi[\alpha]}$ are all those gates of
the form $g_{\phi[\beta]}$, where $\phi$ is an immediate sub-formula of $\psi$
and $\beta$ is an assignment to the free variables of $\psi$ compatible with the
assignment $\alpha$. We show that for a given input structure $\mathcal{A}$ over
the universe $[n]$, $g_{\psi[\alpha]}$ evaluates to one if, and only if,
$\mathcal{A} \models \psi[\alpha]$.

We now construct the circuit $C$ for $\theta(\vec{x})$ and $n$ and prove that
the construction can be completed within a time bound that depends on $n$, the
width of $\theta$ and number of sub-formulas of $\theta$.

\begin{lem}
  There is a function that takes as input a $\FOrk$-formula $\theta(\vec{x})$
  and $n \in \nats$ and outputs a circuit $C$ that translates $\theta(\vec{x})$
  for $n$. Moreover, this function is computable and there is a polynomial in
  $p$ such that for an input $(\theta(\vec{x}), n)$ the algorithm computing this
  function terminates in at most $p(n^{\width(\theta)}\vert \cl{\theta} \vert)$
  many steps.
  \label{lem:translating-FOrk}
\end{lem}
\begin{proof}
  Let $\tau$ be the vocabulary of $\theta(\vec{x})$. Let $k := \width(\theta)$.
  Suppose first that $\tau$ is empty, so
  all of the atomic formulas in $\theta(\vec{x})$ are of the form $y_1 = y_2$,
  where $y_1$ and $y_2$ are variables.  It can be shown that for $\vec{a} \in
  n^k$, we can evaluate $[n] \models \theta[\alpha^{\vec{x}}_{\vec{a}}]$ in time
  polynomial in $n^{k} \vert \cl{\theta} \vert$. Let $f : [n]^k \rightarrow
  \{0,1\}$ be defined such that $f (\vec{a}) = 1$ if, and only if, $[n] \models
  \theta[\alpha^{\vec{x}}_{\vec{a}}]$. Let $C := \langle G, \Sigma, \Omega,
  \Lambda, L \rangle$, where
  \begin{myitemize}
  \item $G = \{g_0, g_1\} \cup \{g_{\vec{a}} : \vec{a} \in [n]^{k}\}$,
  \item $\Sigma (g_0) = 0$, $\Sigma (g_1) = 1$ and $\Sigma (g_{\vec{a}}) =
    \AND[1]$ for all $\vec{a} \in [n]^k$,
  \item $\Omega : [n]^k \rightarrow G$ is defined by $\Omega(\vec{a}) =
    g_{\vec{a}}$ for all $\vec{a} \in [n]^k$,
  \item $\Lambda = \emptyset$, and
  \item for $\vec{a} \in [n]^k$, $L(g_{\vec{a}}) : [1] \rightarrow G$ is defined
    by $L(g_{\vec{a}})(1) = g_{f(\vec{a})}$.
  \end{myitemize}
  
  Since $C$ has symmetric gates, $C$ is transparent. Notice that, since
  $\theta(\vec{x})$ defines a query on structures over the empty vocabulary, we
  have for all $\vec{a} \in [n]^k$, $\sigma \in \sym_n$, $f(\sigma \vec{a}) =
  f(\vec{a})$. For $\sigma \in \sym_n$, let $\pi_\sigma : G \rightarrow G$ be a
  bijection that fixes the constant gates and such that $\pi_{\sigma}
  g_{\vec{a}} = g_{\sigma \vec{a}}$ for all $\vec{a} \in [n]^k$. Then
  $\pi_\sigma \Omega (\vec{a}) = \pi_\sigma g_{\vec{a}} = g_{\sigma \vec{a}} =
  \Omega (\sigma \vec{a})$. It follows that $\pi_\sigma$ is an automorphism of
  the circuit extending $\sigma$. We thus have that $C$ translates
  $\theta(\vec{x})$ for $n$.

  \begin{remark}
    G: I have removed the section where I define equality between ground
    formulas. Do you find this adds ambiguity? I have added a little bit
    explaining what I mean by `the matrix at this point remains unchanged'. Does
    this help?
  \end{remark}
  
  Suppose now $\tau$ is not empty.  We first define a transformation
  of the formula $\theta$ to an equivalent formula $\lambda$ which has
  the property that the \emph{natural} translation of $\lambda$ to a
  circuit (given later) is transparent.
Let $R \in \tau$.  We first define two helper
  formulas. For a variable $y$ let $\op{no-op}(y) := (R(y, y) \lor (\neg R(y,
  y)))$. For a sequence of variables $\vec{y} = (y_1, \ldots, y_m)$ let
  $\op{tag} (\vec{y}) := (\op{no-op}(y_1) \land (\op{no-op}(y_2) \land (
  \op{no-op}(y_2) \land ( \ldots \land (\op{no-op}(y_m)) \ldots))))$.
  Now, let  $\lambda (\vec{x})$ be the formula constructed from $\theta(\vec{x})$ by
  replacing each sub-formula $\psi(\vec{y})$ of the form $\rank^r_p \vec{w}
  \vec{z} . \phi$ with the formula $\rank^r_p \vec{w}\vec{z} . ((\forall u . u =
  u) \land \phi) \land \op{tag}(\vec{w} \cup \vec{z})$.  Since we
  always replace a subformula $\phi$ with a logically equivalent
  formula, it follows that $\lambda
  (\vec{x})$ and $\theta (\vec{x})$ are equivalent. The intuition is that
  $\op{tag}(\vec{w} \cup \vec{z})$ appends a tower of conjunctions of
  tautologies, with each tautology referencing a unique variable from $\vec{w}
  \cup \vec{z}$. When we construct the circuit, this tower of tautologies will
  act to `tag' each input to the rank gate with a unique gadget. We then show
  that the presence of these gadgets ensures that no two inputs to a rank gate
  are syntactically-equivalent, and so the circuit is
  transparent.
  
  %We also relabel the bound variables in $\lambda(\vec{x})$ such that there
  % are
  % no two sub-formulas $\psi$ and $\psi'$ such that $\psi$ and $\psi'$ are
  % equal
  % up to a renaming of those variables that are bound in $\psi$ or $\psi'$.

  % Let $\psi (\vec{y}) \in \FOrk$ and $\alpha \in [n]^{\vec{y}}$. Let
  % $\psi[\alpha]$ be the result of substituting $\vec{y}$ for $\alpha(y)$ in
  % $\psi(\vec{y})$. If $\psi$ is of the form $y_1 = y_2$. Then $\psi [\alpha] =
  % 1$ if $\alpha(y_1) = \alpha (y_2)$ and $\psi[\alpha] = 0$ otherwise.


  We note that $\lambda(\vec{x})$ has the same width as $\theta(\vec{x})$, and
  that the number of sub-formulas in $\lambda(\vec{x})$ is at most $\vert
  \cl{\theta} \vert (5 + 4\width(\theta))$. We now construct a circuit $C$ and
  show that $C$ translates $\lambda(\vec{x})$ (and hence $\theta(\vec{x})$) at
  $n$.

  % We first
  % pre-proccess the formula $\theta(\vec{x})$

  % Let $\op{no-op}(y) := (R(y, y) \land (\neg R(y, y)))$. Let $\vec{y} := (y_1,
  % \ldots, y_k)$ be a vector of variables and $\op{add-tag} (\vec{y}) :=
  % \op{no-op}(y_1) \land (\op{no-op}(y_2) \land ( \op{no-op}(y_2) \land (
  % \ldots
  % \land (\op{no-op}(y_k)) \ldots)))$. From $\theta (\vec{x})$ we construct a
  % new
  % formula $\theta' (\vec{x})$ by replacing each sub-formula $\phi(\vec{y})$ of
  % the form $\rank^r_p \vec{w} \vec{z} . \psi$ by the sub-formula $\rank^r_p
  % \vec{w}\vec{z} . ((\forall u . u = u) \land \phi) \land \op{add-tag}(\vec{w}
  % \cup \vec{z})$.
  Fix $n \in \nats$. Let $\psi \in \FOrk[\tau]$ and $\alpha \in [n]^{\free
    {\psi}}$. We let $\psi[\alpha]$ be the result of substituting each
  occurrence of the free variable $y \in \free{\psi}$ in $\psi$ with
  $\alpha(y)$. If $\psi$ is of the form $y_1 = y_2$, then $\psi [\alpha] = 1$ if
  $\alpha(y_1) = \alpha (y_2)$ and $\psi[\alpha] = 0$ otherwise. We call
  $\psi[\alpha]$ a \emph{ground formula}. For each $\psi \in \cl{\theta}$ let
  $G_\psi := \{g_{\phi[\alpha]} : \alpha \in [n]^{\free{\psi}} \}$. Let $G :=
  \bigcup_{\psi \in \cl{\lambda}} G_{\psi}$. We define $\Sigma$, $\Lambda$ and
  $L$ as follows. Let $\Sigma (g_1) = 1$ and $\Sigma (g_0) = 0$. Let $g :=
  g_{\psi[\alpha]} \in G$.
  
  \begin{myitemize}
  \item If $\psi[\alpha] = T(\vec{a})$ for some $T \in \tau$ and $\vec{a} \in
    \arty(T)$, then $\Sigma (g) = T$ and $\Lambda_T (g) = \vec{a}$.
  \item If $\psi[\alpha]$ is $0$ or $1$, then $\Sigma (g) = \psi[\alpha]$.
  \item If $\psi$ is of the form $\rank^r_p \vec{w} \vec{z}. \phi$, let $A =
    [n]^{\vert \vec{w}\vert}$ and $B = [n]^{\vert \vec{z}\vert}$, and $\Sigma
    (g_{\psi, \alpha}) = \rank[A, B]$. Let $L(g) : A \times B \rightarrow G$ be
    defined by $L(g)(\vec{a},\vec{b}) = g_{\phi[\beta]}$, where $\beta \in
    [n]^{\free{\phi}}$, and where $\alpha$, and the assignments
    $\alpha^{\vec{w}}_{\vec{a}}$ and $\alpha^{\vec{z}}_{\vec{b}}$, are
    compatible with $\beta$.
  \item If $\psi$ is of the form $Q z . \phi(\vec{y}, z)$, for $Q \in \{\forall,
    \exists\}$, then if $Q = \forall$ we have $\Sigma (g) = \AND[n]$,
    otherwise $\Sigma (g) = \OR[n]$. Let $L(g) : [n] \rightarrow G$ be defined
    for $i \in [n]$ by $L(g)(i) = g_{\phi[\beta_i]}$, where $\beta_i \in
    [n]^{\free{\psi}}$, and where both $\alpha$ and $\alpha^{z}_{i}$ are
    compatible with $\beta_i$.
  \item If $\psi$ is of the form $\phi_1 \land \phi_2$, then $\Sigma(g) =
    \AND[2]$ and $L(g) : [2] \rightarrow G$ is defined for $i \in [2]$ by
    $L(g)(i) = g_{\phi_i[\beta_i]}$, where $\beta_i \in [n]^{\free{\psi}}$ and
    $\beta_i$ is compatible with $\alpha$. The same approach is used in the
    disjunctive case.
  \item if $\psi$ is of the form $\neg \phi$ then $\Sigma (g) = \neg$ and $L(g):
    [1] \rightarrow G$ is defined by $L(g)(1) = g_{\phi[\alpha]}$.
  \end{myitemize}

  Let $\Omega : [n]^k \rightarrow G$ be defined by $\Omega (\vec{a}) =
  g_{\lambda [\alpha]}$, where $\alpha := \alpha^{\vec{x}}_{\vec{a}}$, for all
  $\vec{a} \in [n]^k$. Suppose $\Omega (\vec{a}) = g_c$, where $ c \in {0,1}$.
  Then $\lambda$ (and $\theta$) is of the form $(y_1 = y_2)$. But then the
  vocabulary of $\theta$ is empty, contradicting our assumption. Suppose $\Omega
  (\vec{a}) = \Omega(\vec{b})$ for $\vec{a}, \vec{b} \in [n]^k$. Then
  $g_{\lambda[\alpha^{\vec{x}}_{\vec{a}}]} =
  g_{\lambda[\alpha^{\vec{x}}_{\vec{b}}]}$, and so $\alpha^{\vec{x}}_{\vec{a}} =
  \alpha^{\vec{x}}_{\vec{b}}$, and $\vec{a} = \vec{b}$. It follows that $\Omega$
  is injective. Let $T \in \tau$, and let $g_{\psi[\alpha]}, g_{\phi[\beta]} \in
  G$ be such that $\Lambda_T (g_{\psi[\alpha]}) = \Lambda_T (g_{\phi[\beta]})$.
  Then $\psi[\alpha] = \Lambda_T (g_{\psi[\alpha]}) = \Lambda_T
  (g_{\phi[\beta]}) = \phi[\beta]$, and so $g_{\psi[\alpha]} = g_{\phi[\beta]}$.
  It follows that $\Lambda_T$ is injective. We thus have that $C := \langle G,
  \Omega, \Sigma, \Lambda, L \rangle$ is a circuit of order $n$.

\begin{claim}
  The circuit $C$ is symmetric.
\end{claim}
\begin{proof}
  Let $\pi_\sigma : G \rightarrow G$ be a function that fixes constant gates and
  such that if $g_{\psi[\alpha]} \in G$ is a non-constant gate then
  $\pi_{\sigma} g_{\psi [\alpha]} = g_{\psi[\sigma \alpha]}$. It is easy to see
  that $\pi_\sigma$ is a bijection. We now show that $\pi_{\sigma}$ is an
  automorphism of the circuit extending $\sigma$. Let $g_{\psi[\alpha]} := g \in
  G$. Since $\pi_{\sigma}$ acts on gates by permuting the associated assignment,
  but has no effect on the associated sub-formula, we have $\Sigma(g) = \Sigma
  (\pi_{\sigma} g)$. Suppose $g$ is an input gate. If $g$ is a constant gate
  then $\pi_\sigma g = g$. If $g$ is a relational gate, then $\psi$ is of the
  form $T(\vec{y})$ for some relation symbol $T$ and $\Lambda_T
  (g_{\psi[\alpha]}) = \alpha \vec{y}$. It follows that $\Lambda_T (\pi_{\sigma}
  g_{\psi[\alpha]}) = \Lambda_T( g_{\psi[\sigma \alpha]}) = \sigma \alpha
  \vec{y} = \sigma \Lambda_T (g_{\psi[\alpha]})$. Suppose $g$ is an internal
  gate. From the construction of the circuit we have that if $g_{\phi[\beta]}$
  is a child of $g$ then $\phi$ must be an immediate sub-formula of $\psi$ and
  so $g_{\phi[\sigma \beta]}$ is a child of $g_{\psi[\sigma \alpha]} =
  \pi_{\sigma} g$. It follows that $H_{\pi_\sigma g} = \pi_\sigma H_g$. If $g$
  is a symmetric gate, this is sufficient to conclude that $\pi_{\sigma} L(g)$
  is isomorphism-equivalent to $L(\pi_{\sigma} g)$. If $g$ is not a symmetric
  gate then it must be a rank gate, and so $\psi$ is of the form $\rank^r_p
  \vec{w} \vec{z} \phi$. Let $A$ and $B$ be defined as in our definition of $C$,
  and let $\vec{a} \in A$ and $\vec{b} \in B$. Note that $\pi_\sigma L(g)
  (\vec{a}, \vec{b}) = \pi_{\sigma} g_{\phi[\beta]}$, where $\beta \in
  [n]^{\free {\phi}}$ is compatible with $\alpha$, $\alpha^{\vec{w}}_{\vec{a}}$
  and $\alpha^{\vec{z}}_{\vec{b}}$. It follows that $\sigma \beta$ is compatible
  with $\sigma \alpha$, $\sigma \alpha^{\vec{w}}_{\vec{a}} =
  \alpha^{\vec{w}}_{\sigma \vec{a}}$ and $\alpha^{\vec{z}}_{\vec{b}} =
  \alpha^{\vec{z}}_{\sigma \vec{b}}$. We thus have that $L(\pi_{\sigma}
  g)(\sigma \vec{a}, \sigma \vec{b}) = g_{\phi[\sigma \beta]} = \pi_{\sigma}
  g_{\phi[\beta]} = \pi_{\sigma} L(g)(\vec{a}, \vec{b})$. Suppose $g$ is an
  output gate, and let $\vec{a} \in [n]^k$ and $\alpha :=
  \alpha^{\vec{x}}_{\vec{a}}$. We have that $\pi_{\sigma} \Omega (\vec{a}) =
  \pi_\sigma g_{\lambda[\alpha]} = g_{\lambda[\sigma \alpha]} = \Omega (\sigma
  \alpha \vec{x}) = \Omega (\sigma \vec{a})$. This concludes the proof of the
  claim.
\end{proof}
  
Let $\mathcal{A}$ be a $\tau$-structure with universe $U$ of size $n$ and let
$\gamma \in [n]^{\underline{U}}$. It can be shown that for all $\psi \in
\cl{\lambda}$ and $\alpha \in U^{\free{\psi}}$, $\mathcal{A} \models
\psi[\alpha]$ if, and only if, $C[\gamma \mathcal{A}](g_{\psi[\gamma\alpha]}) =
1$. It follows that $\vec{a} \in U^k$ is an element of $Q(\theta(\vec{x}))$ if,
and only if, $\mathcal{A} \models \lambda[\alpha^{\vec{x}}_{\vec{a}}]$ if, and
only if, $C[\gamma \mathcal{A}](g_{\lambda[\alpha^{\vec{x}}_{\gamma \vec{a}}]})
= 1$. Since $g_{\lambda [\alpha^{\vec{x}}_{\gamma \vec{a}}]} = \Omega (\gamma
\vec{a})$, we have that $C$ computes the query defined by $\theta(\vec{x})$ on
structures of size $n$.

\begin{claim}
  The circuit $C$ is transparent.
\end{claim}
\begin{proof}
  If $C$ has symmetric gates then $C$ is transparent. Suppose $C$ contains a
  non-symmetric gate. Let $g_{\psi[\alpha]}\in G$ be a rank gate and suppose
  $\psi$ is of the form $\rank^r_p \vec{w} \vec{z}. \zeta$, where $\zeta =
  \zeta_1 \land \zeta_2$ and where, $\zeta_1 = ((\forall u. u = u) \land \phi)$,
  and $\zeta_2 = \op{tag}(\vec{w} \cup \vec{z})$. Let $\beta_1 , \beta_2 \in
  [n]^{\free{\zeta}}$ both be compatible with $\alpha$, and let $h_1 =
  g_{\zeta[\beta_1]}$ and $h_2 = g_{\zeta[\beta_2]}$. For $i \in [2]$ we have
  that $H_{h_i} = \{g_{\zeta_1[\beta_i]}, g_{\zeta_2[\beta_i]}\}$. Since
  $\zeta_1$ contains a sub-formula of the form $(u = u)$, while $\zeta_2$
  contains no sub-formula with equality, we have that a child of a child of
  $g_{\zeta_1[\beta_1]}$ is a constant gate while none of the children of the
  children of $g_{\zeta_2[\beta_2]}$ are constant gates, and thus $g_{\zeta_1
    [\beta_1]} \not\equiv g_{\zeta_2[\beta_2]}$. It follows that $h_1 \equiv
  h_2$ if, and only if, both $g_{\zeta_1 [\beta_1]} \equiv g_{\zeta_1
    [\beta_2]}$ and $g_{\zeta_2[\beta_1]} \equiv g_{\zeta_2[\beta_2]}$.
  Moreover, the fact that $\zeta_2$ contains an ordered sequence of conjunctions
  of tautologies, with each tautology referencing a different variable,
  guarantees that $g_{\zeta_2[\beta_1]} \equiv g_{\zeta_2[\beta_2]}$ if, and
  only if, $\beta_1$ and $\beta_2$ agree on $\free{\zeta_2}$. But we already
  have that $\beta_1$ and $\beta_2$ are compatible with $\alpha$, and so agree
  on all other free variables. It follows that $g_{\zeta_2[\beta_1]} \equiv
  g_{\zeta_2[\beta_2]}$ if, and only if, $\beta_1 = \beta_2$. This allows us to
  conclude that $g_{\zeta[\beta_1]} \equiv g_{\zeta[\beta_2]}$ if, and only if,
  $\beta_1 = \beta_2$ if, and only if, $g_{\zeta[\beta_1]} =
  g_{\zeta[\beta_2]}$. It follows that $L(g_{\psi[\alpha]})$ is injective, and
  no two child gates of $g_{\psi[\alpha]}$ are syntactically-equivalent. We
  conclude that $g_{\psi[\alpha]}$ has unique labels, and so $C$ is transparent.
\end{proof}

We note that $\vert C \vert \leq n^{\width(\lambda)} \vert \cl{\lambda} \vert
\leq n^{\width(\theta)} \vert \cl{\theta} \vert (5 + \width(\theta))$. It is not
hard to see that $C$ (and $\lambda(\vec{x})$) can be constructed in a number of
steps bounded by a polynomial in the size of $C$. This completes the proof of
the result.


% = C[\gamma \mathcal{A}](\Omega(\gamma \vec{a}))$

% Since $h_{}$Since $\pi_\sigma$ is a bijection, we have that $f$ is a
% bijection. Moreover, we have that $\pi L(g) (a) = L(g) $

% We also have that $\mathcal{A} \models \psi[\gamma \alpha]$ if, and only if,
% $T^{\mathcal{A}} (\gamma \alpha \vec{y})$ if, and only if, $C[\gamma
% \mathcal{A}](g) = 1$

% Suppose $g$ is an internal gate, and we have both the results are true for all
% gates that come before $g$ in the topological ordering of the circuit. Suppose
% $\psi$ is an application of is an application of a logical connective ($land$
% or $\lor$) or negation ($\neg$). We then have that $g$ is a symmetric gate,
% and $f : H_{g} \rightarrow H_{\pi_\sigma g}$ defined by $f(h) = \pi_\sigma h$
% is a bijection.

  
% $\pi_\sigma g_{\psi[\alpha]} = \Lambda_T ()$, for some formula $\psi$
% containing the relation symbol $T$ and assignment $\alpha$, where $\alpha$
% assigns the free variables in $\psi$ to $\vec{a}$. Then $\pi_\sigma g =
% \Lambda^{-1}_T (\sigma \Lambda_T (g)) = g_{\psi[\sigma \alpha]}$. Suppose $g$
% is an internal gate. If $g = g_{psi[\alpha]}$ is an application of a logical
% connective ( $land$ or $\lor$) or negation ($\neg$) then $\pi_{\sigma}g =
% g_{\psi[\sigma \alpha]}$. If $g$

% It can be shown by induction on the structure of the circuit that all
% $g_{\psi[\alpha]} \in G$

% We should note that $C'$ is not, in general, a circuit. This is because it has
% (potentially) more than three constant gates, and perhaps more than one
% relational gate for each assignment and relation symbol. Let $C$ be formed
% from $C'$ by identifying all gates $g$ and $g'$ such that (i) $g$ and $g'$ are
% constant gates and $\Sigma' (g) = \Sigma'(g')$, or (ii) $g$ and $g'$ are
% relational gates, $T := \Sigma' (g) = \Sigma' (g') $, and $\Lambda_T' (g) =
% \Lambda_T'(g')$. We now have $C := \langle G, \Omega, \Sigma, \Lambda, L
% \rangle$. If the domain of $\Omega'$ includes a constant gate, then
% $\theta(\vec{x}) = \Lambda (\vec{x}) = (x_1 = x_2)$

  

% Notice that, formally, $C'$ is not a circuit, in that it contains too many
% relational gates.

% We now show that $C$ translates $\theta(\vec{x})$ at $n$. It is obvious that
% $C$ has order $n$. For $\sigma \in \sym_n$ let $\pi_\sigma : G \rightarrow G$
% be a defined such that $\pi_{\sigma} (g) = g$ if $g \in G_c$ and
% $\pi_\sigma(g_{\psi, \alpha}) = g_{\psi, \sigma \alpha}$ for all $\psi \in
% \cl{\lambda}$ and $\alpha \in n^{\free{\psi}}$. It can be shown that
% $\pi_\sigma$ is an automorphism of $C$ extending $\sigma$. It follows that $C$
% is symmetric.


% Let $\mathcal{A}$ be a $\tau$-structure with a universe $U$ of size $n$ and
% let $\gamma U^{\underline{[n]}}$. Let $\psi (\vec{y}) \in \cl{\lambda}$ and
% let $\alpha \in [n]^{\vec{y}}$. It can be shown by induction on the structure
% of the circuit that for all $\psi (\vec{y})$ and $\alpha \in [n]^{\vec{y}}$,
% $C[\gamma \mathcal{A}](g_{\psi, \alpha}) = 1$ if, and only if, $\mathcal{A}
% \models \psi [\gamma (\alpha \vec{y})]$. It follows that




% Let $\vec{a} \in [n]^k$, and $\alpha \in [n]^{\vec{x}}$ be defined such that
% $\alpha (x_i) = a_i$ for all $i \in [k]$. Then $C[\Omega]$
  

% It is obvious that $C$ has order $n$. Let $\sigma \in \sym_n$. Let $\pi_\sigma
% : G \rightarrow G$ be a defined such that $\pi_{\sigma} (g) = g$ if $g \in
% G_c$ and $\pi_\sigma(g_{\psi, \alpha}) = g_{\psi, \sigma \alpha}$ for all
% $\psi \in \cl{\lambda}$ and $\alpha \in n^{\free{\psi}}$. It can be shown that
% $\pi_\sigma$ is an automorphism of $C$ extending $\sigma$. It follows that $C$
% is symmetric.

% Moreover, let $\alpha \in [n]^{\free{\theta}}$ be an assignment that maps the
% sequence of variables $\vec{x}$ to the tuple $\vec{a} \in [n]^k$. It follows
% that $\Omega (\vec{a}) = g_{\lambda, \alpha}$ evaluates to $1$ If $C$ does not
% contain a rank gate then it is transparent. Suppose $C$ does contain a rank
% gate. Let $g := g_{\psi, \alpha} \in G$ be a rank gate and suppose $\psi
% (\vec{y}) := \rank^r_p \vec{w} \vec{z}. \zeta$, where $\zeta = \zeta_1 \land
% \zeta_2$ and $\zeta_1 = ((\forall u. u = u) \land \phi)$ and $\zeta_2 = \land
% (\op{tag}(\vec{w} \cup \vec{z}))$. Suppose $h_1, h_2 \in H_g$ are
% syntactically-equivalent. It follows that there exist assignments $\beta_1,
% \beta_2 \in [n]^{\vec{w} \cup \vec{z} \cup {y}}$ such that $\alpha \subseteq
% \beta_1$ and $\alpha \subseteq \beta_2$ and $h_1 = g_{\zeta, \beta_1}$ and
% $h_2 = g_{\zeta, \beta_2}$. Then $H_{h_i} = \{g_{\zeta_1, \beta_i},
% g_{\zeta_2, \beta_i}\}$ for $i \in [2]$. Note that a child of a child of
% $g_{\zeta_1, \beta_1}$ is a constant gate while none of the children of the
% children of $g_{\zeta_2, \beta_2}$ are constant gates, and thus $g_{\zeta_1,
% \beta_1} \not\equiv g_{\zeta_2, \beta_2}$ are not syntactically-equivalent. It
% follows that $h_1 \equiv h_2$ if, and only if, both $g_{\zeta_1, \beta_1}
% \equiv g_{\zeta_1, \beta_2}$ and $g_{\zeta_2, \beta_1} \equiv g_{\zeta_2,
% \beta_2}$. However, the construction of $\zeta_2$ (and the fact that $\beta_1$
% and $\beta_2$ agree on the variables in $\vec{y}$) guarantees that
% $g_{\zeta_2, \beta_1} \equiv g_{\zeta_2, \beta_2}$ if, and only if, $\beta_1 =
% \beta_2$ are equal. It follows that $h_1 = g_{\zeta, \beta_1} = g_{\zeta,
% \beta_2} = h_2$. The construction of the circuit guarantees that $g$ has
% injective labels. It follows that $g$ has unique labels, and the circuit $C$
% is transparent.


% and $h := g_{\phi, \beta}$ and $h' := g_{\phi, \beta'}$ are
% syntactically-equivalent. From the construction of $\theta'$ we have that
% $\phi$ must be of a particular form. Suppose $\phi = \eta \land
% \op{add-tag}(\vec{w} \cup \vec{z})$. Let $\gamma$ and $\gamma'$ be the
% restrictions of $\beta$ and $\beta'$ to $\vec{w} \cup \vec{z}$, respectively,
% and let $\zeta(\vec{w}\cup\vec{z}) := \op{add-tag}(\vec{w} \cup \vec{z})$. The
% $\op{add-tag} (\vec{w} \cup \vec{z})$


  

% We notice that $\vert C \vert \leq n^{\width(\lambda)} \vert \cl{\lambda}
% \vert \leq n^{\width(\theta)} \vert \cl{theta} \vert (5 + \width(\theta))$. It
% can be shown that $C$ (and $\lambda(\vec{x})$ can be constructed in a number
% of steps bounded by a polynomial in the size of $C$.



  

  

% If $C'$ contains no rank gates then output $C := C'$. Suppose $C'$ contains at
% least one rank-gate. We note add to $C'$ a gadget that ensures that no two
% input gates to a rank gate can be syntactically-equivalent. Let $\psi \in
% \cl{\theta}$, and suppose $\psi (\vec{y}) = \rank^r_p \vec{w} \vec{z}. \phi$.
% We may think of the assignments to the variables $\vec{w}$ and $\vec{z}$ as
% being the row and column indexes of the matrix. We

% Then for $\alpha \in [n]^{\free (\psi)}$, $H_{g_{\psi, \alpha}}$ consists of
% gates of the form $g_{\phi, \beta}$, where $\beta \in [n]^{\vec{w} \cup
% \vec{z} \cup \vec{y}}$ and $\alpha subseteq \beta$.

% Let $T_{\psi, \alpha} : H_{g_{\psi, \alpha}} \rightarrow [n]^{\vert \vec{w}
% \vert + \vert \vec{z} \vert}$ be defined by $T_{\psi, \alpha} (g_{\phi,
% \beta}) = \beta (\vec{z} \cup \vec{w})$ for all $g_{\phi, \beta} \in H_g$.
% What $T_{\psi, \alpha}$ does is assign to each child of $g_{\psi, \alpha}$ an
% ordered sequence formed Let $T$ be the union of all $T_{\psi}$ and $H$ the
% union of all $G_{\psi}$ for all $\psi \in \cl{\theta}$ an application of the
% rank operator. Let $C := \op{tag-all}(C', R, H, T)$. We note that
% $\op{tag-all}$ may be computed in time polynomial in the size of the input
% circuit.

% Let $a \in [n]$ and let $\op{no-op} (a) := R(a, a) \lor (\neg (R(a, a))$. For
% $\psi (\vec{y})$

% % Let $(b_1, \ldots, b_m) := \beta (\vec{w} \cup \vec{z})$. The $\op{tag-all}
% % function replaces each input $g_{\phi, \beta}$ of the rank gate $g_{\psi,
% % \alpha}$ with the circuit $g_{\phi, \beta} \land \op{no-op}(b_1) \land
% % (\op{no-op}(b_2) \land ( \op{no-op}(b_2) \land (\ldots \land
% % (\op{no-op}(b_m))
% % \ldots)))$. This construction does not effect the evaluation of any rank
% % gate
% % in the cirucit and ensures that no two to $g_{\psi,\alpha}$ in $C$ are
% % syntactically-equivilent.


% $of the form $$R(a, a) \lor (\neg R(a, a))$ that encode the assignment to
% $\vec{w}\cup \vec{z}$.

% We have that $C$ is transparent, has order $n$, and $C$ and $C'$ decide the
% same query. It remains to show that $C$ is still symmetric.

% However, the $\op{tag-all}$ operation adds a tower of tautologies of the form
% $R(a, \ldots, a) \lor (\neg R (a, \ldots, a))$


% Let $g := g_{\psi, \alpha} \in G$ be a rank gate and let $h, h' \in H_g$.
% Suppose $\psi (\vec{y}) := \rank^r_p \vec{w} \vec{z}. \phi$ and $h := g_{\phi,
% \beta}$ and $h' := g_{\phi, \beta'}$ are syntactically-equivalent. From the
% construction of $\theta'$ we have that $\phi$ must be of a particular form.
% Suppose $\phi = \eta \land \op{add-tag}(\vec{w} \cup \vec{z})$. Let $\gamma$
% and $\gamma'$ be the restrictions of $\beta$ and $\beta'$ to $\vec{w} \cup
% \vec{z}$, respectively, and let $\zeta(\vec{w}\cup\vec{z}) :=
% \op{add-tag}(\vec{w} \cup \vec{z})$. The $\op{add-tag} (\vec{w} \cup \vec{z})$


% The structure of this formula gives us that $h$ is syntactically-equivalent to
% $h'$ if, and only if, $g_{\zeta , \beta'}$




% We also note that $C$ has order $n$.
\end{proof}

We now use Lemma~\cite{lem:translating-FOrk} to prove that for every $\FPR$
formula there is a corresponding $\PT$-uniform family of transparent symmetric
rank-circuits that decides the same query.

\begin{thm}
  For each $\FPR$-formula $\theta(\vec{x})$ there exists a family of circuits
  $(C_n)_{n \in \nats}$ that translates $\theta(\vec{x})$.
  \label{thm:translating-formulas-to-circuits}
\end{thm}
\begin{proof}
  Let $\theta(\vec{x}) \in \FPR[\tau]$ and $t := \width (\theta)$. We begin by
  showing that there exists a $\PT$-uniform family of formulas
  $(\theta(\vec{x}))_{n \in \nats}$ such that for each $n \in \nats$, we have
  $\theta_n(\vec{x}) \in \FOrk[\tau]$, $\width(\theta_n) \leq 4 t$, and
  $\theta_n(\vec{x})$ is equivalent to $\theta(\vec{x})$ on structures of size
  $n$. This result follows from two observations.

  First, using the translation in~\cite{Dawar09logicswith}, we have that for any
  $\phi(\vec{x}) \in \FPR[\tau]$ there is a mapping $n \mapsto \phi_n(\vec{x})$
  computable in time polynomial in both $n$ and the size of $\phi(\vec{x})$, and
  such that for all $n \in \nats$, we have $\phi_n(\vec{x}) \in \FOR[\tau]$,
  $\width (\phi_n) \leq 2 \cdot \width (\phi)$, and $\phi_n(\vec{x})$ and
  $\phi(\vec{x})$ are equivalent on structures of size $n$.

  Second, using the translation in~\cite{libkin2004elements}, we have that if
  $\phi (\vec{x}) \in \FOR[\tau]$, then there is a mapping $n \mapsto \phi_n$
  computable in time polynomial in both $n$ and the size of $\phi(\vec{x})$, and
  such that for all $n \in \nats$, $\phi_n(\vec{x}) \in \FOrk[\tau]$,
  $\width(\phi_n) \leq 2 \cdot \width(\phi)$, and $\phi_n(\vec{x})$ and
  $\phi(\vec{x})$ are equivalent on structures of size $n$.

  \begin{remark}
    A: Need more specific references than the above.
  \end{remark}

  We thus derive the required $\PT$-uniform family $(\theta_n(\vec{x}))_{n \in
    \nats}$ by applying the first translation and then the second. For each $n
  \in \nats$ let $C_n$ be the output of the function defined in
  Lemma~\ref{lem:translating-FOrk} for the input $\theta_n(\vec{x})$ and $n$. We
  have from Lemma~\ref{lem:translating-FOrk} that for all $n \in \nats$, $C_n$
  translates $\theta_n(\vec{x})$, and hence $\theta(\vec{x})$, for $n$.
  Moreover, we note that $\theta_n$ can be computed in time polynomial in $n$
  and $C_n$ can be computed in time polynomial in $n^{\width(\theta_n)} \vert
  \cl{\theta_n} \vert$. We note that $\width(\theta_n) \leq 4t$ and
  $\cl{\theta_n}$ must be bounded by a polynomial in $n$ (since $\theta_n$ is a
  member of a $P$-uniform family of circuits). It follows that the function $n
  \mapsto C_n$ is computable in time polynomial in $n$, and so $(C_n)_{n \in
    \nats}$ translates $\theta(\vec{x})$.
\end{proof}


% \begin{proof}
%   We say that a circuit $C$ \emph{translates} a formula $\psi(\vec{x})$ for $n
%   \in \nats$ if $C$ is a transparent symmetric rank-circuit of order $n$ and
%   $C$ computes the query defined by $\psi(\vec{x})$ on structures of size $n$.
%   We say a family of circuits $(C_n)_{n \in \nats}$ \emph{translates} a
%   formula $\psi (\vec{x})$ if $(C_n)_{n \in \nats}$ is $\PT$-uniform and for
%   all $n \in \nats$, $C_n$ translates $\psi(\vec{x})$ for $n$.

%   %   We have from Anderson and Dawar~\cite{AndersonD17} that for every
%   %   formula
%   %   $\phi(\vec{x}) \in \FPC[\tau]$ there is a $\PT$-uniform family of
%   %   symmetric
%   %   circuits $(C^{\phi}_n)_{n \in \nats}$ with unique labels and symmetric
%   %   gates
%   %   that translates $\phi(\vec{x})$.
  
%   Let $\theta(\vec{x}) \in \FPR[\tau]$ and $t := \width (\theta)$. We begin by
%   showing that there exists a $P$-uniform family of formulas
%   $(\theta(\vec{x}))_{n \in \nats}$ such that for each $n \in \nats$, we have
%   $\theta_n(\vec{x}) \in \FOrk[\tau]$, $\width(\theta_n) \leq 4 t$, and
%   $\theta_n(\vec{x})$ is equivalent to $\theta(\vec{x})$ on structures of size
%   $n$. This result follows from two observations.

%   First, using the translation in~\cite{Dawar09logicswith}, we have that for
%   any $\phi(\vec{x}) \in \FPR[\tau]$ of the form $\lfp{V,
%   \vec{y}}{\psi(\vec{x}, \vec{y}, V)}(\vec{x})$ , there is a mapping $n
%   \mapsto \phi_n$, computable in time polynomial in both $n$ and the size of
%   $\phi(\vec{x})$ such that for all $n \in \nats$, we have $\phi_n(\vec{x})
%   \in \FOR[\tau]$, $\width (\phi_n) \leq 2 \cdot \width (\phi)$, and
%   $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are equivalent on structures of size
%   $n$.

%   Second, using the translation in~\cite{libkin2004elements}, we have that if
%   $\phi (\vec{x}) \in \FOR[\tau]$ is of the form $\rank (\vec{y}\vec{\mu} \leq
%   \vec{t}, \vec{z}\vec{\nu} \leq \vec{s}, \pi \leq r) . \psi
%   (\vec{y}\vec{\mu}, \vec{z} \vec{\nu})$, then there is a mapping $n \mapsto
%   \phi_n$ computable in time polynomial in both $n$ and the size of
%   $\phi(\vec{x})$ such that for all $n \in \nats$, $\phi_n(\vec{x}) \in
%   \FOrk[\tau]$, $\width(\phi_n) \leq 2 \cdot \width(\phi)$, and
%   $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are equivalent on structures of size
%   $n$.

%   We thus derive the required $\PT$-uniform family $(\theta_n(\vec{x}))_{n \in
%   \nats}$ by applying the first translation and then the second. Let $x$ be a
%   variable and $R \in \tau$. Let $\op{no-op}(x) := R(x, x) \land (\neg R(x,
%   x))$. Let $\vec{x} := (x_1, \ldots, x_k)$ and $\op{add-tag} (\vec{x}) :=
%   \op{no-op}(x_1) \land (\op{no-op}(x_2) \land ( \ldots \land
%   (\op{no-op}(x_k)) \ldots)$. For each $\theta_n (\vec{x})$ we construct a new
%   formula $\theta_n' (\vec{x})$ by replacing each sub-formula $\phi(\vec{y})$
%   of $\theta_n(\vec{x})$ of the form $\rank^r_p \vec{w} \vec{z} . \psi$ by
%   $\rank^r_p \vec{w}\vec{z} . (\psi \land \op{add-tag}(\vec{w} \cup
%   \vec{z}))$. It is easy to see that we can construct $\theta_n'$ from
%   $\theta_n$ in time polynomial in $\theta_n$. Moreover, $\theta_n'$ and
%   $\theta_n$ are equivalent and have the same width.

  

  
%   Fix $n \in \nats$. We now construct a circuit $C_n$ that translates
%   $\theta_n'$ (and hence $\theta_n$ and $\theta$) at $n$. For each $\psi \in
%   \cl{\theta_n}$ let $G_\psi := \{g_{\psi, \alpha} : \alpha \in
%   [n]^{\free{\psi}} \}$. Let $G := \bigcup_{\psi \in \cl{\theta_n}} G_{\psi}$.
%   Let $g_{\psi, \alpha} \in G$. We define $\Sigma$, $\Lambda$ and $L$ as
%   follows.
%   \begin{itemizens}
%   \item If $\psi (\vec{y}) = R(\vec{y})$, for some $R \in \tau$, then $\Sigma
%     (g_{\psi, \alpha}) = R$ and $\Lambda_R (g_{\psi, \alpha}) = \alpha
%     \vec{y})$.
%   \item If $\psi (y_1, y_2) = (y_1 = y_2)$, then if $\alpha (y_1) = \alpha
%     (y_2)$, $\Sigma (g_{\psi, \alpha}) = 1$, else $\Sigma (g_{\psi, \alpha}) =
%     0$.
%   \item if $\psi (\vec{y}) = \rank^r_p \vec{w} \vec{z}. \phi$, then $\Sigma
%     ()$
%   \end{itemizens}

 
  

%   We first consider the base case. Suppose $\psi(\vec{y})$ is an atomic
%   formula. Then $\psi(\vec{y}) \in \FPC[\tau]$, and so, using the translation
%   defined by Anderson and Dawar~\cite{AndersonD17}, there exists a family of
%   circuits $(C^{\psi}_n)_{n \in \nats}$ that translates $\psi(\vec{y})$. Let
%   $T_n(\psi(\vec{y})) := C^{\psi}_n$.

%   We now consider the conjunctive case. Suppose $\psi(\vec{y})$ is a
%   sub-formula of $\theta_n(\vec{x})$ such that $\psi (\vec{y}) =
%   \phi_1(\vec{y}) \land \phi_2(\vec{y})$. Let $R_{\phi_1}$ and $R_{\phi_2}$ be
%   two $\vert \vec{y} \vert$-ary relation symbols not in $\tau$ and let $\psi'
%   (\vec{y}) := R_{\phi_1}(\vec{y}) \land R_{\phi_2}(\vec{y})$. Then
%   $\psi'(\vec{y}) \in \FPC[\tau]$ and so, using the translation defined by
%   Anderson and Dawar, there exists a circuit family $(C^{\psi'}_n)_{n \in
%   \nats}$ that translates $\psi'(\vec{y})$. Let $T_n(\psi (\vec{y})) :=
%   \op{compose}(C^{\psi'}_n, ( T_n(\phi_1(\vec{y})), T_n(\phi_2(\vec{y}))),
%   (R_{\phi_1}, R_{\phi_2}))$. We note that $T_n(\psi(\vec{y}))$ translates
%   $\psi (\vec{y})$ at $n$ if $T_n(\phi_1 (\vec{y}))$ and
%   $T_n(\phi_2(\vec{y}))$ translate $\phi_1(\vec{y})$ and $\phi_2(\vec{y})$ at
%   $n$, respectively.

%   The approach used in the conjunctive case can be summarised as follows.
%   Given a sub-formula $\psi (\vec{y})$, we construct an auxiliary formula
%   $\psi'(\vec{y})$ in which all the sub-formulas of $\psi(\vec{y})$ are
%   replaced with relation symbols. We then construct a circuit $C^{\psi'}$ that
%   translates $\psi'(\vec{y})$ at $n$ using the translation defined by Anderson
%   and Dawar. Finally, we recursively construct circuits that translate the
%   sub-formulas of $\psi(\vec{y})$, and compose these circuits with
%   $C^{\psi'}$.
  
%   This approach can be used in order to handle every case with the exception
%   of rank. In other words, we can use a similar approach to define
%   $T_n(\psi(\vec{y}))$ where $\psi(\vec{y})$ is a sub-formula of
%   $\theta_n(\vec{x})$ of the form $\phi_1(\vec{y}) \lor \phi_2(\vec{y})$,
%   $\neg \phi(\vec{y})$, $\forall z. \phi (\vec{y}, z)$, or $\exists z. \phi
%   (\vec{y}, z)$.

%   We now handle the rank case. The approach is quite similar, except in this
%   case we cannot use the translation defined by Anderson and Dawar in order to
%   translate the auxiliary formula, and so must define this translation
%   explicitly. Moreover, rather than just composing the circuits, we also add a
%   small gadget in order to ensure the resultant circuit is transparent.
  
%   Suppose $\psi(\vec{z}, \vec{w}, \vec{y})$ is a sub-formula of
%   $\theta_n(\vec{x})$ such that $\psi (\vec{y}) = \rank^{\leq r}_p \vec{z},
%   \vec{w} .\phi(\vec{z}, \vec{w}, \vec{y})$, for some $p, r \in \nats$ and $p$
%   prime. Let $k:= \vert \vec{y} \vert$, $k_1 : = \vert \vec{z} \vert$ and $k_2
%   := \vert \vec{w} \vert$. Let $R_\phi$ be a $(k_1 + k_2 + k)$-ary relation
%   symbol not in $\tau$. Let $\psi'(\vec{y}) := \rank^{\leq r}_p\vec{z},
%   \vec{w}. R_{\phi} (\vec{z}, \vec{w}, \vec{y})$. Let $G_{\text{out}} :=
%   \{g_{\vec{c}} : \vec{c} \in [n]^k\}$ and $G_{\text{in}} : = \{ g_{\vec{a},
%   \vec{b}, \vec{c}} : \vec{a} \in [n]^{k_1}, \vec{b} \in [n]^{k_2}, \vec{c}
%   \in [n]^{k}\}$. Let $C^{\psi'}_n:= \langle G^{\psi'}, \Omega^{\psi'},
%   \Sigma^{\psi'}, \Lambda^{\psi'}, L^{\psi'}\rangle$ be a
%   $(\mathbb{B}_{\rank}, \{ R_{\phi} \})$-circuit such that
%   \begin{itemizens}
%   \item $G^{\psi'} = G_{\text{out}} \cup G_{\text{in}}$,
%   \item $\Omega^{\psi'}$ be an injection from $[n]^k$ to $G^{\psi'}$ defined
%     by $\Omega^{\psi'}(\vec{c}) = g_{\vec{c}}$ for all $\vec{c} \in [n]^k$,
%   \item $\Sigma^{\psi'} (g) = \rank^r_p$ if $g \in G_{\text{out}}$ and
%     $\Sigma^{\psi'}(g) = R_\phi$ if $g \in G_{\text{in}}$,
%   \item for each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$,
%     $\Lambda^{\psi'} (\vec{a}, \vec{b}, \vec{c}) = g_{\vec{a}, \vec{b},
%     \vec{c}}$, and
%   \item for each gate $g_{\vec{c}} \in G_{\text{out}}$, $L(g_{\vec{c}}):
%     [n]^{k_1} \times [n]^{k_2} \rightarrow G^{\psi'}$ is defined by
%     $L(g_{\vec{c}})(\vec{a}, \vec{b}) := g_{\vec{a}, \vec{b}, \vec{c}}$ for
%     each $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.
%   \end{itemizens}

%   We note that $C^{\psi'}_n$ translates $\psi (\vec{y})$ at $n$. Let $R$ be a
%   relation symbol in $\tau$. Let
%   \begin{align*} T_n(\psi(\vec{y})) := \op{compose-and-tag}(C^{\psi'}_n,
%     (T_n(\phi(\vec{z}, \vec{w}, \vec{y}))), (R_\phi), R).
%   \end{align*}

%   We recall that $\op{compose-and-tag}$ combines circuits in a similar way to
%   $\op{compose}$ except that it also adds a set of gadgets to the circuit
%   ensuring that no two child gates of an output gate are
%   syntactically-equivalent. We thus have that $T_n(\psi (\vec{y}))$ is
%   transparent if $T_n(\phi (\vec{z}, \vec{w},\vec{y}))$ is transparent, and
%   $T_n(\psi(\vec{y}))$ translates $\psi (\vec{y})$ at $n$ if $T_n(\phi
%   (\vec{z}, \vec{w},\vec{y}))$ translates $\phi(\vec{z}, \vec{w}, \vec{y})$ at
%   $n$.

%   We have completed our definition of $T_n$ and shown, by induction on the
%   structure of $\theta_n(\vec{x})$, that for each $\psi (\vec{y})$ a
%   sub-formula of $\theta_n(\vec{x})$, $T_n(\psi(\vec{y}))$ translates
%   $\psi(\vec{y})$ at $n$.

%   The above definition can be used to define a recursive algorithm computing
%   the function $n \mapsto T_n (\theta_n(\vec{x}))$. We note that, since
%   $\width(\theta_n) \leq 4 t$ for all $n \in \nats$, there are only a finite
%   number of cases that need to be considered at each recursive step in this
%   algorithm. This fact can be used to show that there exists a polynomial
%   bound on the running time of the algorithm that depends only on $n$ and the
%   structure of $\theta(\vec{x})$. As such, we have that $(T_n (\theta_n))_{n
%   \in \nats}$ translates $\theta(\vec{x})$, and the result follows.
% \end{proof}

% \ifcsdef{mainfile}{}{\bibliography{../references.bib}}
\end{document}
