\documentclass[../paper.tex]{subfiles}
\begin{document}
In this section we first introduce a number of useful polynomial-time computable
functions which define transformations on circuits. In the second subsection we
use these these functions to define a transformation of $\FPR$-formulas into
equivalent families of transparent rank-circuits.

\subsection{Algorithms for Circuits}
In order to simplify the presentation of the translation between $P$-uniform
families of circuits and formulas of $\FPR$, as well as the proofs of other
results (see Lemma~\ref{lem:transparent-unique}), we define a number of
often-used polynomial-time computable circuit transformations.

We first define the function $\op{merge}$, which maps a circuit and a set of
syntactically-equivalent gates to a circuit formed by combining those gates into
a single gate.

\begin{definition}
  Let $C := \langle G, \Omega, \Sigma , \Lambda, L \rangle$ be a circuit and $H
  := \{h_1, \ldots, h_p\}$ be a set of syntactically equivalent gates. We let
  $\op{merge}(C, H) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{h_2, \ldots, h_q\}$,
  \item $\Omega' = \Omega$,
  \item $\Sigma' = \restr{\Sigma}{G'}$,
  \item $\Lambda' = \Lambda$, and
  \item For all $g \in G'$ and $\vec{a} \in Ind(g)$ if $L(g) (\vec{a}) \in H$
    then $L'(g)(\vec{a}) = h_1$ and if $L(g)(\vec{a}) \notin H$ then
    $L'(g)(\vec{a}) = L(g)(\vec{a})$.
  \end{itemize}
\end{definition}

It can be shown that $\op{merge}$ can be computed in time polynomial in the size
of the input circuit. We note that the input and output circuits compute the
same function. Moreover, if the input circuit is symmetric (resp. has unique
labels, is transparent) then the output circuit will also be symmetric (resp.
have unique labels, is transparent).

We now define the function $\op{merge-all}$ which maps a circuit and a set of
gates to a new circuit formed by applying $\op{merge}$ to the
syntactic-equivalence classes of the set of gates.

\begin{definition}
  \label{def:merge-all}
  The function $\op{merge-all}$ maps a circuit $C$ and a set of gates $H$ to a
  circuit $\op{merge-all}(C, H) := C'$, where $C'$ is defined as follows. Let
  $H_1, \ldots, H_p$ be the syntactic equivalence classes of $H$, and let $C'$
  be defined from $C$ by successively applying $\op{merge}$ to each of these
  equivalence classes.
\end{definition}

We can compute $\op{merge-all}$ using the following algorithm. Let $(C, H)$ be a
tuple in the domain of $\op{merge-all}$. We assume a reasonable encoding of the
circuit, and note that any such encoding induces a linear order on the
structure. Let $H_1, \ldots, H_p$ be the syntactic equivalence classes of $H$
linearly ordered such that for all $i, j \in [p]$ if $i \leq j$ the height of
the gates in $H_i$ is less than or equal to the height of the gates in $H_j$.
Let $C'$ be the result of successively executing the algorithm for $\op{merge}$
on each such equivalence class in order.

It is worth noting that for an input tuple $(C, H)$, if follows from
Lemma~\cite{lem:unique-labels-syntactic-equiv} that if $H$ has unique labels
then the syntactic equivalence relation on $H$ can be computed in time
polynomial in the size of $C$. Thus, if the set $H$ has unique labels, it can be
shown that the operation $\op{merge-all}$ can be computed in time polynomial in
the size of the input circuit.

As in the case of $\op{merge}$, the function $\op{merge-all}$ preserves
symmetry, unique labels and the ensures that the input and output circuits
compute the same function. Let be a circuit $C$ a circuit and $H$ a set of gates
in $C$ with unique labels. Then if $g$ is a gate in both $C$ and $C' :=
\op{merge-all}(C, H)$, and all of the children of $g$ in $C$ are in $H$, then no
two distinct children of $g$ in $C'$ are syntactically-equivalent. We note we
have no guarantee that $g$ will have unique labels in $C'$ as $L'(g)$ may not be
injective.

% Moreover, if we run merge on a circuit $C$ and a set $H$ then if $C$ has
% unique labels and $H$ has the property that there is no gate $g$ in $C$ such
% that two elements of $H$ are in $H_g$ then if $C$ has unique labels then so
% does $C'$. Moreover, if $C$ is symmetric then so is $C'$.

The now define the function $\op{make-injective}$ that maps a circuit and a
symmetric gate to an equivalent circuit containing all the same gates as the
input circuit but such that the specified gate now has injective labels.

\begin{definition}
  \label{def:make-injective}
  The function $\op{make-injective}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ and a gate $h \in G$ to the circuit
  $\op{make-injective}(C, h) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, defined as follows. Let $c = \max \{\vert L(g)^{-1}(h)\vert : g \in
  W(h, \cdot)\}$. If $c = 1$ then $C' := C$. If $c > 1$ then $C'$ is defined
  such that
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \uplus \{h_2, \ldots, h_{c-1}\}$,
  \item $\Omega' = \Omega$,
  \item For each $g \in G$ let $\Sigma' (g) = \Sigma(g)$, otherwise let
    $\Sigma'(g)$ be a single-input $\AND$-gate.
  \item $\Lambda'= \Lambda$
  \item For each $g \in G'$ if $g \in G \setminus W(h, \cdot)$ then $L'(g) =
    L(g)$. If $g \in W(h, \cdot)$ let $\{\vec{a}_1, \ldots, \vec{a}_k\} :=
    L(g)^{-1}(h)$ and for each $\vec{a} \in \ind(g)$ if $L(g)(\vec{a}) \neq h$
    then $L'(g)(\vec{a}) = L(g)(\vec{a})$ and if $\vec{a} = \vec{a_i} \in
    L(g)^{-1}(h)$ then let $L'(g)(\vec{a}) = h_i$.
  \end{itemize}
\end{definition}

It can be shown that $\op{make-injective}$ can be computed by an algorithm
running in time polynomial in the size of the input circuit. Moreover, the input
and output circuits of this operation compute the same function.

% Furthermore, $\op{make-injective}(C, h) = C'$ and there exists a symmetric
% gate $g \in C$ such that $\vert L(g)^{-1}(h) \vert > 1$ then the number of
% non-injective symmetric gates in $C'$ is strictly less than the number of
% non-injective symmetric gates in $C'$.

We now define the function $\op{make-injective-all}$ that maps a circuit to an
equivalent circuit such that every symmetric gate now has injective labels.

\begin{definition}
  The function $\op{make-injective-all}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ to a circuit $\op{make-injective}(C) := C' :=
  \langle G', \Omega', \Sigma', \Lambda', L' \rangle$ defined as follows.

  Let $F$ be a function that maps an ordered circuit $C*$ to the circuit
  $\op{make-injective}(C*, h)$, where $h$ is the topologically first gate such
  that there exists a gate $g$ in $C*$ where $h$ is a child of $g$ and $\vert
  L*(g)^{-1}(h) \vert > 1$. Let $(C^0, C^1, \ldots)$ be a sequence of circuits
  where $C^0 := C$ and for $i > 1$, $C^i := F(C^{i-1})$. It can be shown that
  this sequence converges after at most $\vert C \vert$ many steps. Let $C'$ be
  the limit of this sequence.
\end{definition}

Since $\op{make-injective}$ can be computed in polynomial time, and the number
of iterations required to converge to the limit in the above definition is
bounded by the size of the circuit, it can be shown that
$\op{make-injective-all}$ can be computed in time polynomial in the size of the
input circuit. Furthermore, we note that $\op{make-injective-all}$ preserves
symmetry, rigidity and unique labels. Moreover, the input and output circuits
compute the same function.


% $ $g$ in $C$ such that $W(h,g)$, let $g_{h_1}$ be the first gate in the
% circuit such that for all $g' \in S_j$, $\vert L(g_{h_1})^{-1}(h_1) \vert \geq
% L(g')^{-1}(h_1)$
  

% We define $C'$ as follows. Let $F$ be a function that takes in an ordered
% circuit $C = \langle G, \Omega, \Sigma, \Lambda, L \rangle$ and outputs a
% circuit $C* := \langle G, \Omega, \Sigma, \Lambda, L \rangle$ defined as
% follows. If for all $g \in G$, $L(g)$ is an injection then $F(C) = C$ and if
% not then $F(C)$ is defined as follows.


% Let $j \in [\depth(C)]$, and let ${G_0}' = G$, ${\Sigma_0}' = \Sigma$ and
% ${L}_0' = L$.


% Let $S_j$ be the set of all gates of height $j$ that are symmetric-gates. For
% each $h_1 \in \bigcup_{g \in S_j} H_g$ let $g_{h_1} \in S_j$ be the first gate
% in the circuit such that for all $g' \in S_j$, $\vert L(g_{h_1})^{-1}(h_1)
% \vert \geq L(g')^{-1}(h_1)$. Let $(a_1, \ldots, a_p) := L(g_{h_1})^{-1}(h_1)$
% (ordered according the to order on the circuit). We add to $G'$ the gates
% $\{h_2, \ldots, h_p\}$ and for each $i \in \{2, \ldots, p\}$ we set
% $\Sigma'(h_i)$ such that $h_i$ is a $\land$ gate with a single output and
% $L'(h_i)$ such that $h_i$ takes only $h_{i-1}$ as an input. For each $g' \in
% S$ such that $h_1 \in H_g$ let $\{ b_1, \ldots, b_q \} := L(g)^{-1}(h_1)$. For
% each $i \in [q]$ let $L'(g')(b_i) = h_i$. Iterate $k$ and repeat this
% procedure until $k$ exceeds the depth of the circuit.

% \begin{definition}
%   The operation \emph{separate-labels} takes as input an ordered $(\mathbb{B},
%   \tau)$-circuit $C := \langle G, \Omega, \Sigma , \Lambda, L \rangle$ and
%   outputs the circuit $C' = \langle G', \Omega', \Sigma', \Lambda', L'
%   \rangle$. We define $C'$ as follows. Let $j \in [\depth(C)]$, and let
%   ${G_0}' = G$, ${\Sigma_0}' = \Sigma$ and ${L}_0' = L$. Let $S_j$ be the set
%   of all gates of height $j$ that are symmetric-gates. For each $h_1 \in
%   \bigcup_{g \in S_j} H_g$ let $g_{h_1} \in S_j$ be the first gate in the
%   circuit such that for all $g' \in S_j$, $\vert L(g_{h_1})^{-1}(h_1) \vert
%   \geq L(g')^{-1}(h_1)$. Let $(a_1, \ldots, a_p) := L(g_{h_1})^{-1}(h_1)$
%   (ordered according the to order on the circuit). We add to $G'$ the gates
%   $\{h_2, \ldots, h_p\}$ and for each $i \in \{2, \ldots, p\}$ we set
%   $\Sigma'(h_i)$ such that $h_i$ is a $\land$ gate with a single output and
%   $L'(h_i)$ such that $h_i$ takes only $h_{i-1}$ as an input. For each $g' \in
%   S$ such that $h_1 \in H_g$ let $\{ b_1, \ldots, b_q \} := L(g)^{-1}(h_1)$.
%   For each $i \in [q]$ let $L'(g')(b_i) = h_i$. Iterate $k$ and repeat this
%   procedure until $k$ exceeds the depth of the circuit.
% \end{definition}

% Notice that for a given circuit $C$ and a symmetric-gate $g$ in $C$, running
% `merge' on each equivalence class of syntactically equivalent gates input to
% $g$ and then running `separate-labels' on the resultant circuit produces
% circuit $C'$ computing the same function as $C$ but the gate $g$ in $C$ has
% unique labels.

We now define the function $\op{insert}$ that maps two circuits to a circuit
formed by inserting the gates of the first circuit into the second circuit.

\begin{definition}
  The function $\op{insert}$ maps a $(\mathbb{B}_1, \tau_1)$-circuit $C^1 :=
  \langle G_1, \Omega_1, \Sigma_1 , \Lambda_1, L_1 \rangle$ and a
  $(\mathbb{B}_2, \tau_2)$-circuit $C^2 := \langle G_2, \Omega_2, \Sigma_2 ,
  \Lambda_2, L_2 \rangle$ to a $(\mathbb{B}_1 \cup \mathbb{B}_2, \tau_1 \uplus
  \tau_2)$-circuit $\op{insert}(C^1, C^2) := C := \langle G, \Omega, \Sigma ,
  \Lambda, L \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G = G_1 \uplus G_2$,
  \item $\Omega = \Omega_2$,
  \item $\Sigma = \Sigma_1 \uplus \Sigma_2$,
  \item $\Lambda = \Lambda_1 \uplus \Lambda_2$, and
  \item $L = L_1 \uplus L_2$.
  \end{itemize}
\end{definition}

It can be shown that $\op{insert}$ can be be computed in time polynomial in the
size of the input circuits. Moreover, if the input circuits are symmetric then
the output circuit will be symmetric.

We now define the function $\op{replace}$ that maps a circuit $C$ and a pair of
gates $(g_1, g_2)$ in $C$ to a circuit $C'$ formed by replacing $g_1$ with $g_2$
in $C$.

\begin{definition}
  The function $\op{replace}$ maps a circuit $C = \langle G, \Omega, \Sigma,
  \Lambda, L\rangle$ and a pair of gates $(g_1, g_2)$ in $C$ to a circuit
  $\op{replace}(C, g_1, g_2) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{g_1\}$,
  \item $\Omega'$ is an function from the domain of $\Omega$ to $G'$ such that
    for each $\vec{a} \in \dom(\Omega)$ if $\Omega(\vec{a}) = g_1$ then
    $\Omega'(\vec{a}) = g_2$ and otherwise $\Omega'(\vec{a}) = \Omega(\vec{a})$.
  \item $\Sigma' = \restr{\Sigma}{G'}$
  \item $\Lambda' = \restr{\Lambda}{G'}$
  \item For each $g \in G'$ and each $\vec{a} \in \ind(g)$ if $L(g)(\vec{a}) =
    g_1$ then $L'(g)(\vec{a}) = g_2$ and if not then $L'(g)(\vec{a}) =
    L(g)(\vec{a})$.
  \end{itemize}
\end{definition}

It can be shown that the function $\op{replace}$ can be computed in time
polynomial in the size of the input circuit.

We now define the function $\op{tag}$ that maps a circuit, a relation symbol, a
gate in that circuit, and a tuple to a circuit computing the same function as
the input circuit but with an additional gadget, constructed using the gates
labelled by the given relation symbol and tuple, marking the designated gate.
The intuition is that this marking helps to distinguish a gate, and is used as a
step to ensure that a circuit has unique labels.

\begin{definition}
  The function $\op{tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle G,
  \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a gate $g \in G$, and a tuple $\vec{a} \in [n]^k$ for some $k$ to a
  circuit $\op{tag}(C, R, g, \vec{a}) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$, such that $G' = G \uplus \{\land_g,
  \land_{g'}, \land_1, \ldots , \land_k\}$, $\Omega' = \Omega$, and $\Lambda' =
  \Lambda$. For each $g \in G$ $\Sigma'(g) = \Sigma(g)$. For each $g \in
  \{\land_0, \land_1, \ldots , \land_k \}$, $\Sigma(g)$ is an $\AND$-gate that
  takes in two inputs. $\Sigma(\land_g)$ is an $\AND$-gate that takes in a
  single input, $g$ is the lone input to $\land_g$, and $\land_0$ has as input
  $\land_g$ and $\land_1$. For each $i \in [k-1]$ the inputs of $\land_i$ are
  $\land_{i+1}$ and the gate $g_i \in G'$ such that $\Sigma(g_i) = R$ and
  $\Lambda^{-1}(g_i) = \vec{a}_i$, where $\vec{a}_i$ is the $k$-tuple
  $(\vec{a}(i), \ldots, \vec{a}(i))$. The inputs of $\land_k$ are the constant
  gate $1$ and the gate $g_k$ such that $\Sigma(g) = R$ and $\Lambda^{-1}(g_k) =
  \vec{a}_k$. For each gate $h \in G \setminus \{g\}$ and $\vec{b} \in \ind(h)$,
  if $L(h)(\vec{b}) = g$ then $L'(h)(\vec{b}) = \land_0$, otherwise
  $L'(h)(\vec{b}) = L(h)(\vec{b})$.
\end{definition}

% \begin{definition}
%   The algorithm \emph{tag} takes in a $(\mathbb{B}, \tau)$-circuit $C_n :=
%   \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a relation symbol $R \in
%   \tau$, a gate $g \in G$ and a tuple $\vec{a} \in [n]^k$ for some $k$ and
%   outputs the circuit $C_n' = \langle G', \Omega', \Sigma', \Lambda',
%   L'\rangle$ defined by the following algorithm. Let $G' = G \uplus \{\land_g,
%   \land_{g'}, \land_1, \ldots , \land_k\}$, $\Omega' = \Omega$, and $\Lambda'
%   = \Lambda$. Define $L'$ and $\Sigma'$ as follows. For each $g \in G$
%   $\Sigma'(g) = \Sigma(g)$. For each $g \in \{\land_0, \land_1, \ldots ,
%   \land_k \}$, $\Sigma(g)$ is an $\AND$-gate that takes in two inputs.
%   $\Sigma(\land_g)$ is an $\AND$-gate that takes in a single input. Set $g$ to
%   be the lone input to $\land_g$. Set the two inputs to $\land_0$ to be
%   $\land_g$ and $\land_1$. For each $i \in [k-1]$ set the inputs of $\land_i$
%   to be $\land_{i+1}$ and the gate $g_i \in G'$ such that $\Sigma(g_i) = R$
%   and $\Lambda^{-1}(g_i) = \vec{a}_i$, where $\vec{a}_i$ is the $k$-tuple
%   $(\vec{a}(i), \ldots, \vec{a}(i))$. Set the inputs of $\land_k$ to be the
%   constant gate $1$ and the gate $g_k$ such that $\Sigma(g) = R$ and
%   $\Lambda^{-1}(g_k) = \vec{a}_k$.

%   For each gate $h \in G \setminus \{g\}$ and $\vec{b} \in \ind(h)$, if
%   $L(h)(\vec{b}) = g$ then let $L'(h)(\vec{b}) = \land_0$, otherwise let
%   $L'(h)(\vec{b}) = L(h)(\vec{b})$.

% \end{definition}

It can be shown that $\op{tag}$ can be computed in time polynomial in the size
of its input. The input and output circuits compute the same function. Moreover,
if the input circuit has unique labels then the output circuit will have unique
labels. If the input relation symbol is obvious from the context we omit it when
invoking $\op{tag}$.

\begin{definition}
  The function $\op{tag-all}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a set of gates $H \subseteq G$, and $T := (\vec{a}_h)_{h \in H}
  \subseteq [n]^{k}$ a sequence of tuples indexed by $H$ for some fixed $k$, to
  a circuit $\op{tag-all}(C, R, H, T) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$ defined as follows.

  Suppose there is a linear order on $H$, and write $H = \{h_1, \ldots, h_t\}$.
  Let $C_0 := C$ and for all $i \in [t]$ let $C_i := \op{tag}(C_{i-1}, R, h_i,
  T(h_i))$. Then $C' = C_{t}$.

  % such that $G' = G \uplus \{\land_g, \land_{g'}, \land_1, \ldots ,
  % \land_k\}$,
  % $\Omega' = \Omega$, and $\Lambda' = \Lambda$. For each $g \in G$ $\Sigma'(g)
  % =
  % \Sigma(g)$. For each $g \in \{\land_0, \land_1, \ldots , \land_k \}$,
  % $\Sigma(g)$ is an $\AND$-gate that takes in two inputs. $\Sigma(\land_g)$ is
  % an $\AND$-gate that takes in a single input, $g$ is the lone input to
  % $\land_g$, and $\land_0$ has as input $\land_g$ and $\land_1$. For each $i
  % \in
  % [k-1]$ the inputs of $\land_i$ are $\land_{i+1}$ and the gate $g_i \in G'$
  % such that $\Sigma(g_i) = R$ and $\Lambda^{-1}(g_i) = \vec{a}_i$, where
  % $\vec{a}_i$ is the $k$-tuple $(\vec{a}(i), \ldots, \vec{a}(i))$. The inputs
  % of
  % $\land_k$ are the constant gate $1$ and the gate $g_k$ such that $\Sigma(g)
  % =
  % R$ and $\Lambda^{-1}(g_k) = \vec{a}_k$. For each gate $h \in G \setminus
  % \{g\}$ and $\vec{b} \in \ind(h)$, if $L(h)(\vec{b}) = g$ then
  % $L'(h)(\vec{b})
  % = \land_0$, otherwise $L'(h)(\vec{b}) = L(h)(\vec{b})$.
\end{definition}

It is easy to see that, since $\op{tag}$ can be computed in time polynomial in
the combined size of its inputs, $\op{tag-all}$ can also be computed in time
polynomial in the combined size of its inputs.

We now define the function $\op{compose}$ that maps a circuit and a sequence of
appropriate circuits and to a circuit formed by replacing the input gates of the
designated circuit with the output gates of the circuits in the sequence of
circuits.

\begin{definition}
  The function $\op{compose}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation sybmols $\tau_R
  := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence of
  circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose}(C,
  \mathcal{C}, \tau_R) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$. Note that all circuits take in structures of size $n$. The circuit
  $C'$ is defined as follows.
  
  Let ${C^0}' := \langle G_0', \Omega_0', \Sigma_0', \Lambda_0', L_0' \rangle :=
  C$, and let $i \in [t]$. Let $D^{i-1}:= \op{insert} (C^i, {C^{i-1}}')$ and
  $G^{i-1}_{R_i}$ be the set of all relational gates in $D^{i-1}$ labelled by
  the relational symbol in $R_i$. Let ${C^{i-1}}' := \langle G_i', \Omega_i',
  \Sigma_i', \Lambda_i', L_i' \rangle$ be the circuit formed from $D^{i-1}$ by
  replacing each gate in $g \in G^{i-1}_{R_i}$ with the gate
  $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ (by repeated calls to the
  $op{replace}$ function). Let $C' = {C^{t}}'$.
\end{definition}

% \begin{definition}
%   The function $\op{concatenate}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
%   \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation
%   sybmols $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a
%   sequence of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i
%   \in [t]$, $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is
%   a $(\mathbb{B}_i, \tau_i)$-circuit, $\tau_i \not\subset \tau_R$ and $C^i$
%   computes a query of arity $\arty(R_i)$, and $R$ is a relation symbol in
%   $(\tau \setminus \tau_R) \cup (\bigcup_{1 \leq i \leq t},\tau_i))$ to a
%   circuit $\op{concatenate}(C, \mathcal{C}, \tau_R, R) := C' := \langle G',
%   \Omega', \Sigma', \Lambda', L' \rangle$. Note that all circuits take in
%   structures of size $n$. The circuit $C'$ is defined as follows.
  
%   Let ${C^0}' := \langle G^0, \Omega^0, \Sigma^0, \Lambda^0, L^0 \rangle :=
%   C$. For each $i \in [t]$ fix a relation symbol $V_i \in \tau_i \setminus
%   \tau_R$. For each $i \in [t]$ let ${C^{i}}' := \langle G_i', \Omega_i',
%   \Sigma_i', \Lambda_i', L_i' \rangle := \op{insert} (C^i, {C^{i-1}}')$ be
%   defined as follows. Let $D^{i-1}:= \op{insert} (C^i, {C^{i-1}}')$. Let
%   $G_{R_i}$ be the set of all relational gates in $D^{i-1}$ labelled by the
%   relational symbol in $R_i$. Let ${C^{i}}'$ be the circuit formed by
%   replacing each gate in $g \in G_{R_i}$ with the gate
%   $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ (by repeated calls to the
%   $op{replace}$ function) and using the $\op{tag}$ function on each gate
%   $\Omega_i (\Lambda_{i-1}'(g))$ in $D^{i-1}$ using the tuple
%   $\Lambda_{i-1}'(g)$ and the relation symbol $V_i$. We then let $C' :=
%   {C^{t}}'$.

%   %   For each relational gate $g$ in $D^{i-1}$ labelled by the symbol
%   %   $R_i$,
%   %   $\op{replace}$ $g$ with the gate $\Omega_{i}(\Lambda_{i-1}'(g))$ in
%   %   $D^{i-1}$
%   %   and $\op{tag}$ the gate $\Omega_i(\Lambda_{i-1}'(g))$ in $D^{i-1}$
%   %   using
%   %   the
%   %   tuple $\Lambda_{i-1}'(g)$ and the relation symbol $R$. Output the
%   %   circuit
%   %   $C'
%   %   := {C^t}'$.
% \end{definition}
% GW: do this tomorrow.

% \begin{definition}
%   The operation $\op{concatenate-circuits}(C, \mathcal{C}, \tau_R) = C'$,
%   where $C := \langle G, \Omega, \Sigma, \Lambda_0, L_0 \rangle$ is a
%   $(\mathbb{B}, \tau)$-circuit, $\mathcal{C}$ is a finite set of circuits
%   takes as input a set of relation symbols $\tau_R := \{R_1, \ldots, R_t\}$
%   and $t+1$ circuits $\{C^0, \ldots, C^{t}\}$, where $C^0 = \langle G_0,
%   \Omega_0, \Sigma_0, \Lambda_0, L_0 \rangle$ is a $(\mathbb{B},
%   \tau)$-circuit with $\tau_R \subseteq \tau$ and for each $i \in [t]$, $C^i =
%   \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
%   $(\mathbb{B}_i, \tau_i)$-circuit computing a query of arity $\arty(R_i)$.
%   The algorithm outputs, for a given input, a circuit $C = \langle G, \Omega,
%   \Sigma, \Lambda, L\rangle$ constructed as follows. Let ${C^0}' := C^0$. For
%   each $i \in [t]$ fix a relation symbol $V_i \in \tau_i \setminus \tau_R$.
%   For each $i \in [t]$ construct the circuit ${C^{i}}' = \langle G_i',
%   \Omega_i', \Sigma_i', \Lambda_i', L_i' \rangle $ by `inserting' $C^i$ into
%   ${C^{i-1}}'$, and call the resultant circuit ${D^{i-1}}'$. For each
%   relational gate $g$ in $D^{i-1}$ labelled by the symbol $R_i$, `replace' $g$
%   with the gate $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ and `tag' the
%   gate $\Omega_i(\Lambda_{i-1}'(g))$ in $D^{i-1}$ using the tuple
%   $\Lambda_{i-1}'(g)$ and the relation symbol $V_i$. Output the circuit $C :=
%   {C^t}'$.
% \end{definition}

It can be shown that $\op{compose}$ can be computed in time polynomial in the
sum of the sizes of the input circuits. Moreover, if the input circuits are all
symmetric then the output circuit will be symmetric. Also, for an input tuple
$(C, \mathcal{C}, \tau_R)$, we have that if $C$ has symmetric gates and
transparent, and all the circuits in $\mathcal{C}$ are transparent, then $C' :=
\op{compose}(C, \mathcal{C}, \tau_R)$ is transparent. If $C$ does not have
symmetric gates then, as the output gates of the circuits in $\mathcal{C}$ are
no longer labelled as output gates in $C'$, it may be that some of these gates
are syntactically-equivalent in $C'$, resulting in $C'$ not being transparent.

In certain contexts we are interested composing gates such that if the input circuits are
transparent (resp. have unique labels) then the output circuits will be
transparent (resp. have unique labels). In this case, while composing the
circuits we could apply the $\op{tag}$ function to the output gates of the
circuits in the input sequence. We now define the function
$\op{compose-and-tag}$ that implements this mapping.

\begin{definition}
  The function $\op{compose-and-tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
  \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation symbols
  $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence
  of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose-and-tag}(C,
  \mathcal{C}, \tau_R, R) := C'$. The circuit $C'$ is defined as follows. Note
  that all circuits take in structures of size $n$.
  
  Let $D^0 := \op{compose}(C, \mathcal{C}, \tau_R)$. For each $i \in [t]$, let
  $D^{i} := \op{tag-all}(D^{i-1}, R, \img(\Omega^{-1}_i), \Omega^{-1}_i)$. Let
  $C' := D^t$.
\end{definition}

It is easy to see that $\op{compose-and-tag}$ can be computed in time polynomial
in the sizes of the input circuits. Furthermore, if the input sequences of
circuits and relations are both singletons, then if the input circuits are all
transparent (resp. have unique labels) then the output circuit is transparent
(resp. have unique labels).

\subsection{Translating FPR to Symmetric Matrix Circuits}
In this subsection we translate $\FPR$-formulas into families of transparent
rank-circuits. In particular, we now show that for $\theta(\vec{x}) \in
\FPR[\tau]$ there exists a $P$-uniform family of symmetric rank-circuits
$(C_n)_{n \in \nats}$ such that the query computed by $(C_n)_{n \in \nats}$ is
equal to the query defined by $\theta (\vec{x})$.

% From Lemma \cite{} we may assume, without a loss of generality, that $(C_n)_{n
% \in nats}$ is a family of rigid circuits (and hence has unique labels).

\begin{thm}
  For any relational vocabulary $\tau$ and each $\theta(\vec{x}) \in \FPR[\tau]$
  there is a map $n \mapsto C_n$, where $C_n$ is a transparent symmetric
  rank-circuit, and is computable in time polynomial in $n$. The family of
  circuits $(C_n)_{n \in \nats}$ defined by this mapping computes the same query
  as the one defined by $\theta(\vec{x})$.
  \label{thm:translating-formulas-to-circuits}
\end{thm}

\begin{proof}
  We say a formula $\psi(\vec{x})$ is \emph{circuit-translatable} if there is a
  $P$-uniform family of transparent symmetric rank-circuits computing the query
  as the one defined by $\psi(\vec{x})$. If a formula $\psi(\vec{x})$ is
  circuit-translatable we let $(C^\psi_n)_{n \in \nats}$ denote a $P$-uniform
  family of transparent symmetric rank-circuits computing the same query as
  defined by $\psi(\vec{x})$.
  
  Let $\theta(\vec{x}) \in \FPR[\tau]$. We prove that $\theta(\vec{x})$ is
  circuit-translatable by structural induction. That is, we prove that if every
  sub-formula of $\theta(\vec{x})$ is circuit-translatable then
  $\theta(\vec{x})$ is circuit-translatable. Since it is obvious that every
  atomic formula in $\FPR[\tau]$ is circuit-translatable, the result thus
  follows. We already have that the formulas of $\FPC[\tau]$ are
  circuit-translatable (Anderson and Dawar~\cite{AndersonD17}), and in fact we
  may assume, without a loss of generality, that this translation yields a
  family of transparent circuits with unique labels (and unique extensions).

  We begin by showing that for any $\theta(\vec{x}) \in \FPR[\tau]$, there
  exists a $P$-uniform family of formulas $(\theta(\vec{x}))_{n \in \nats}$ such
  that for each $n \in \nats$, $\theta_n(\vec{x})$ is a first order formula with
  counting and rank quantifiers and is equivalent to $\theta(\vec{x})$ on
  structures of size $n$. This fact follows immediately from three observations.
  First, we note that for any $\phi \in FPR[\tau]$ of the form $\lfp{V,
    \vec{y}}{\psi(\vec{x}, \vec{y}, V)}(\vec{x})$ , there is a mapping $n
  \mapsto \phi_n$, computable in time polynomial in $n$, such that for all $n
  \in \nats$, both $\phi_n$ and $\phi$ are equivalent on structures of size $n$,
  and $\phi_n$ contains no least-fixed-point operator. The formula $\phi_n$ is
  define from $\phi$ by `unfurling' the least-fixed-point operator, producing,
  for a given $n \in \nats$, a formula that explicitly implements the definition
  of the operator in the obvious manner (for details on this implementation see
  \ref{}). This construction of $\phi_n$ involves adding a constant number of
  terms to $\phi$ for each iteration involved in computing the
  least-fixed-point. Since there are at most $n^k$ such iterations, where $k$ is
  the width of the formula $\psi$, the construction of $\phi_n$ can be completed
  in time polynomial in $n$.

  Similar arguments holds for number terms and rank operators. We have
  from~\cite{} that for any formula $\phi$ containing number-terms there is a
  $P$-uniform family of formulas $(\phi_n)_{n \in \nats}$ containing counting
  quantifiers and no number-terms, and such that for all $n \in \nats$, $\phi$
  and $\phi_n$ are equivalent on structures of size $n$. We have from Dawar et
  al.~\cite{Dawar09logicswith} that for every formula $\phi \in \FPR[\tau]$
  containing rank operators, there exists a $P$-uniform family that takes as
  input a natural number $n$ and outputs a formula $\phi_n$ with rank
  quantifiers and no rank operators, and such that for all $n \in \nats$, $\phi$
  and $\phi_n$ are equivalent on structures of size $n$.

  The algorithm given by executing each of the above three algorithms in
  succession computes the required mapping $n \mapsto \theta_n(\vec{x})$ in time
  polynomial in $n$, thus giving us the required $P$-uniform family
  $(\theta_n(\vec{x}))_{n \in \nats}$.

  It follows that the number of sub-formulas of $\theta_n$

  It follows that in order to prove that $\theta(\vec{x})$ is
  circuit-translatable it is sufficient to prove that there exists a function
  that maps $\theta_n$ (for any $n \in \nats$) to $C^{\theta}_n$, a transparent
  symmetric rank-circuit that computes the same query as defined by
  $\theta_n(\vec{x})$ (and so $\theta(\vec{x})$) for structures of size $n$, and
  is computable in time polynomial in in both $n$ and the number of sub-formulas
  in $\theta_n$. This is sufficient as the number of sub-formulas in $\theta_n$
  is bounded by some polynomial in $n$, and so composing functions, we can
  compute the map that takes $n$ to $\theta_n$ to $C^{\theta}_n$ in time
  polynomial in $n$.
  
  We define an algorithm for constructing $C^{\theta}_n$ given
  $\theta_n(\vec{x})$ by recursion on the structure of the input formula. The
  first note that if $\theta_n(\vec{x})$ an atomic formula then there is a
  trivial construction of $C^{\theta}_n$.

  We consider the conjunctive case. Suppose $\phi_1, \phi_2 \in \FPR[\tau]$ are
  circuit-translatable and $\theta (\vec{x}) = \phi_1(\vec{x}) \land
  \phi_2(\vec{x})$. Let $R_{\phi_1}$ and $R_{\phi_2}$ be two $\vert \vec{x}
  \vert$-ary relation symbols not in $\tau$. Let $\theta' (\vec{x}) :=
  R_{\phi_1}(\vec{x}) \land R_{\phi_2}(\vec{x})$. Let $n \in \nats$. Since
  $\theta'(\vec{x})$ is a formula of $\FPC[\tau]$, we have from Anderson and
  Dawar~\cite{AndersonD17} that $\theta'(\vec{x})$ is circuit-translatable. We
  let $C^{\theta}_n := \op{compose}(C^{\theta'}, (C^{\phi_1}, C^{\phi_2}),
  (R_{\phi_1}, R_{\phi_2}))$.

  Since all internal gates in $C^{\theta'}$ are symmetric, and both $C^{\phi_1}$
  and $C^{\phi_2}$ are transparent, it follows that $C^{\theta}_n$ is
  transparent. Moreover, it is easy to see that the construction of
  $C^{\theta}_n$ can be carried implemented so as to run in time polynomial in
  $n$, and that $(C^{\theta}_n)_{n \in \nats}$ computes the same query defined
  by $\theta(\vec{x})$. It follows that $\theta(\vec{x})$ is
  circuit-translatable.
  
  % Notice that $D^{\theta}_n$ computes the same relation as defined by
  % $\theta(\vec{x})$ for structures of size $n$. Moreover, since the remaining
  % two operations preserve the function computed, it follows $C^{\theta}_n$
  % computes the same relation as defined by $\theta(\vec{x})$ for structures of
  % size $n$. Furthermore, since $C^{\phi_1}_n$, $C^{\phi_2}_n$ and
  % $C^{\theta'}_n$ are symmetric so is $C^{\theta}_n$. Lastly, notice that all
  % non-output gates in $D^{\theta}_n$ have unique labels. After the
  % $\op{merge-all}$ and $\op{make-injective-all}$ operation the output gates
  % have
  % unique labels, and thus $C^{\theta}_n$ has unique labels. This construction
  % takes in a natural number $n$ and produces the required circuit
  % $C^{\theta}_n$. Moreover, it is easy to see that this construction can be
  % implement as an algorithm running in time polynomial in $n$. It follows that
  % $\theta(\vec{x})$ is circuit-translatable.

  The approach used for resolving the conjunctive case can be thought of as
  having three steps. First, replacing each sub-formula in $\theta$ with a
  relation symbol, resulting in a formula $\theta'$ of $\FPC$. Second, using the
  algorithms from the inductive hypothesis' (and the results of Anderson and
  Dawar) on $\theta'$ and the sub-formulas, producing appropriate families for
  $\theta'$ and each sub-formula of $\theta$. Third, for each $n \in \nats$
  composing the circuit $C^{\theta'}_n$ with the circuits for each sub-formula,
  producing the the circuit $C^{\theta}_n$. Since this process can be executed
  in time polynomial in $n$, we conclude that $\theta$ is circuit-translatable.
  
  This same approach can be used to handle many other cases. For
  circuit-translatable $\phi, \phi_1, \phi_2 \in \FPR[\tau]$, and $k \in \nats$,
  similar constructions can be used to prove that if $\theta(\vec{x}) \in
  \FPR[\tau]$ is of the form $\phi_1(\vec{x}) \lor \phi_2(\vec{x})$, $\neg
  \phi(\vec{x})$, $\forall y. \phi (\vec{x}, y)$, $\exists y. \phi (\vec{x}, y)$
  or $C^k y. \phi(\vec{x}, y)$ then $\theta(\vec{x})$ is circuit-translatable.

  % Suppose $\phi(\vec{x},y) \in \FPR[\tau]$ is circuit-translatable and
  % $\theta(\vec{x}) := C^{k}y. \phi(\vec{x}, y)$. Let $k := \vert \vec{x}
  % \vert$
  % and $R$ be a $(k+1)-$-ary relational symbol. Let $D_n$ be a $(\MB,
  % \{R\})$-circuit computing the $k$-ary query such that for each $\vec{a} \in
  % [n]^k$, the output gate labelled by $\vec{a}$ computes the Boolean function
  % \begin{align*}
  %   \countgate_{\vec{a}} &(x_{(\vec{a}, 1)}, \ldots, x_{({\vec{a}, n})}) 
  %                          := \\ & \begin{cases} \land ( \maj ( x_{(\vec{a}, 1)}, \ldots, x_{(\vec{a}, n)},
  %                            \underbrace {0, \ldots, 0}_{2k - n} ), \neg ( \maj ( x_{(\vec{a}, 1)},
  %                            \ldots, x_{(\vec{a}, n)}, \underbrace{0, \ldots,
  %                              0}_{2k - n + 2} ) )) &  k \geq \frac{n}{2} \\
  %                            \land ( \maj ( x_{(\vec{a}, 1)}, \ldots, x_{(\vec{a}, n)}, \underbrace {1,
  %                              \ldots, 1}_{n - 2k} ), \neg ( \maj ( x_{(\vec{a}, 1)}, \ldots,
  %                            x_{(\vec{a}, n)}, \underbrace{1, \ldots, 1}_{n - 2k -2} ) )) & k <
  %                            \frac{n}{2},
  %                          \end{cases}
  % \end{align*}
  % using the obvious circuit (for a more detailed construction see the proof of
  % Proposition~\ref{prop:fuctions-maj}), and where for each $i \in [n]$, the
  % variable $x_{(\vec{a}, i)}$ is replaced by the relational gate in the
  % circuit
  % labelled by $(\vec{a}, i)$. Then $C^{\theta}_n := \op{compose}(D_n,
  % {C^\phi_n}, \{R\})$. It is easy to see that this construction can be carried
  % out in time polynomial in $n$.

  % GW: include here the result of inserting the circuit

  Suppose $\phi(\vec{z}, \vec{y}, \vec{x}) \in \FPR[\tau]$ is
  circuit-translatable, $p$ is a prime, $r$ is a natural number, and
  $\theta(\vec{x}) := \rank^{\leq r}_p \vec{z} \vec{y}. \phi(\vec{z}, \vec{y},
  \vec{x})$. We define an algorithm that takes as input a natural number $n$
  outputs the required circuit $C^{\theta}_n$.

  From the inductive hypothesis we may efficiently compute $C^{\phi}_n = \langle
  G^{\phi}, \Omega^{\phi}, \Sigma^{\phi}, \Lambda^{\phi}, L^{\phi} \rangle$. Let
  $k:= \vert \vec{x} \vert$, $k_1 : = \vert \vec{z} \vert$ and $k_2 := \vert
  \vec{y} \vert$. Let $R_\phi$ be a $(k_1 + k_2 + k)$-ary relation symbol not in
  $\tau$.

  Let $\theta'(\vec{x}) = \rank^{\leq r}_r := \vec{z}, \vec{y}. R_{\phi}
  (\vec{z}, \vec{y}, \vec{x})$. We define the $(\mathbb{B}_{\rank}, \{ R_{\phi}
  \})$-circuit $C^{\theta'}_n:= \langle G^{\theta'}, \Omega^{\theta'},
  \Sigma^{\theta'}, \Lambda^{\theta'}, L^{\theta'}\rangle$ as follows. Let
  $G_{\text{out}} := \{g_{\vec{c}} : \vec{c} \in [n]^k\}$ and $G_{\text{in}} : =
  \{ g_{\vec{a}, \vec{b}, \vec{c}} : \vec{a} \in [n]^{k_1}, \vec{b} \in
  [n]^{k_2}, \vec{c} \in [n]^{k}\}$.
  
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item Let $G^{\theta'} = G_{\text{out}} \uplus G_{\text{in}}$,
  \item $\Omega^{\theta'}$ be an injection from $[n]^k$ to $G^{\theta'}$ defined
    by $\Omega^{\theta'}(\vec{c}) = g_{\vec{c}}$ for all $\vec{c} \in [n]^k$,
  \item $\Sigma^{\theta'} (g) = \rank^r_p$ if $g \in G_{\text{out}}$ and
    $\Sigma^{\theta'}(g) = R_\phi$ if $g \in G_{\text{in}}$,
  \item For each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$ let
    $\Lambda^{\theta'} (\vec{a}, \vec{b}, \vec{c}) := g_{\vec{a}, \vec{b},
      \vec{c}}$, and
  \item For each gate $g_{\vec{c}} \in G_{\text{out}}$ let $L(g_{\vec{c}}):
    [n]^{k_1} \times [n]^{k_2} \rightarrow G^{\theta'}$ be defined by
    $L(g_{\vec{c}})(\vec{a}, \vec{b}) := g_{\vec{a}, \vec{b}, \vec{c}}$ for each
    $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.
  \end{itemize}
 
  % It is easy to see that both $C^{\theta'}_n$ (and $C^{\phi}_n$) are symmetric
  % rank-circuits with unique labels.


  % It is easy to see that every gate in $$

  % be the result of calling $\op{tag}$ on


  % Let $C^{\theta}_n := \op{make-injective-all}(\op{merge-all}(D_n, H))$.
  Let $R$ be a relation symbol in $\tau$. Let $C^{\theta}_n :=
  \op{compose-and-tag}(C^{\theta'}_n, (C^{\phi}_n), (R_\phi), R)$. It is easy to
  see that for all $n \in \nats$, $C^{\theta}_n$ computes the same query as
  defined by $\theta(\vec{x})$ for structures of size $n$. Moreover, since
  $C^{\theta'}_n$ and $C^{\phi}_n$ are symmetric, transparent, and the input
  sequences of relations and circuits are singletons, it follows that
  $C^{\theta}_n$ is a transparent symmetric rank-circuit. W have thus defined a
  mapping from $n \mapsto C^{\theta}_n$, that, and that mapping can be computed
  in time polynomial in $n$.
 
  It remains only to note that any atomic formula of $\FPR[\tau]$ is trivially
  circuit-translatable. The result thus follows.
\end{proof}


% \begin{proof}
%   We say a formula $\psi(\vec{x}) \in \FPR[tau]$ is
%   \emph{circuit-translatable} if there is a $P$-uniform family of symmetric
%   matrix-circuits with unique labels that compute the same query as
%   $\psi(\vec{x})$. If a formula $\psi(\vec{x}) \in \FPR[tau]$ is
%   matrix-circuit-translatable we let $(C^\psi_n)_{n \in \nats}$ denote the
%   corresponding $P$-uniform family of symmetric matrix-circuits with unique
%   labels.

%   We prove that $\theta(\vec{x}) \in \FPR[\tau]$ is circuit-translatable by
%   structural induction. That is, we first prove that if every sub-formula of
%   $\theta(\vec{x})$ is circuit-translatable then $\theta(\vec{x})$ is
%   circuit-translatable and, second, we note that every atomic formula in
%   $\FPR[\tau]$ is circuit-translatable. We have already that formulas of
%   $\FPC[\tau]$ are circuit translatable (Anderson and
%   Dawar~\cite{AndersonD17}), and in fact we may assume, without a loss of
%   generality, that this translation yields a family of rigid circuits.
  
%   %   It is sufficient to prove that if $\theta(\vec{x})$ has the property
%   %   that
%   %   all
%   %   of its subformulas have are matrix-circuit-translatable then there is an
%   %   algorithm that takes in a natural number $n$ and outputs a symmetric
%   %   matrix-circuit $C^\theta_n$ with unique labels that is equivalent to
%   %   $\theta(\vec{x})$ on structures of size $n$.
  
%   We first consider the case where $\theta(\vec{x})$ is a conjunction of
%   matrix-circuit-translatable formulas. Suppose $\phi_1, \phi_2 \in
%   \FPR[\tau]$ are matrix-circuit-translatable and $\theta (\vec{x}) =
%   \phi_1(\vec{x}) \land \phi_2(\vec{x})$. Let $R_{\phi_1}$ and $R_{\phi_2}$ be
%   two $\vert \vec{x} \vert$-ary relation symbols not in $\tau$. Let $\theta'
%   (\vec{x}) := R_{\phi_1}(\vec{x}) \land R_{\phi_2}(\vec{x})$. Let $n \in
%   \nats$. Since $\theta'(\vec{x})$ is a formula of $\FPC$, we may efficiently
%   compute $C^{\theta'}_n$ using the construction in \cite{AndersonD17}. From
%   the inductive hypothesis, for each $i \in \{1,2\}$ we may efficiently
%   compute the circuit $C^{\phi_i}_n = \langle G_i, \Omega_i, \Sigma_i
%   Lambda_i, L_i \rangle$. Let $R \in \tau$ and let $D^{\theta}_n :=
%   \op{compose}(C^{\theta'}_n, (C^{\phi_1}_n, C^{\phi_2}_n), (R_1, R_2), R)$.
%   Let $H$ consist of all non-output gates in $D^{\theta}_n$. From the
%   inductive hypothesis all gates in $H$ have unique labels. Let $C^{\theta}_n
%   := \op{make-injective-all}(\op{merge-all}(D^{\theta}_n, H))$.
  
%   Notice that $D^{\theta}_n$ computes the same relation as defined by
%   $\theta(\vec{x})$ for structures of size $n$. Moreover, since the remaining
%   two operations preserve the function computed, it follows $C^{\theta}_n$
%   computes the same relation as defined by $\theta(\vec{x})$ for structures of
%   size $n$. Furthermore, since $C^{\phi_1}_n$, $C^{\phi_2}_n$ and
%   $C^{theta'}_n$ are symmetric so is $C^{\theta}_n$. Lastly, notice that all
%   non-output gates in $D^{\theta}_n$ have unique labels. After the
%   $\op{merge-all}$ and $\op{make-injective-all}$ operation the output gates
%   have unique labels, and thus $C^{\theta}_n$ has unique labels. This
%   construction takes in a natural number $n$ and produces the required circuit
%   $C^{\theta}_n$. This construction can be computed by an algorithm in time
%   polynomial in $n$. Thus $\theta(\vec{x})$ is matrix-circuit-translatable.

%   %   We construct the circuit $C'_n = \langle G', \Omega', \Sigma',
%   %   \Lambda', L' \rangle$ by `inserting' $C^{\phi_1}_n$ and $C^{\phi_2}_n$
%   %   into
%   %   $C^{\theta'}_n$. We now construct $C^{\theta}_n$ from $C'_n$ as follows:
%   %   \begin{itemize}
%   %   \item For each $i \in \{1,2\}$ and each relational gate $g$ in $C_n$
%   %     such
%   %     that $\Sigma'(g) = R_{\phi_i}$ `replace' $g$ with
%   %     $\Omega_i(\Lambda_i(g))$,
%   %   \item then, for each syntactic equivalence class $H \subseteq
%   %     \range(\Omega_1) \uplus \range(Omega_2)$, `merge' $H$, and finally
%   %   \item run `separate-labels' on the circuit.
%   %   \end{itemize}

%   %   We note that, since $C^{\phi_1}_n$, $C^{\phi_2}_n$ and $C^{\theta'}_n$
%   %   have
%   %   unique labels, the only gates that might not have unique labels in
%   %   $C^{\theta}_n$ are those whose input gates include gates in the range of
%   %   $\Omega_1$ or $\Omega_2$. However, all such gates are symmetric and
%   %   steps
%   %   (2)
%   %   and (3) above guarantee that these gates have unique labels. Finally, we
%   %   note
%   %   that this algorithm can implemented such that the computation of
%   %   $C^{\theta}_n$ from $n$ runs in time polynomial in $n$.

%   The approach used above for resolving the conjunctive case can be thought of
%   as having three steps. First, replacing each sub-formula with a relation
%   symbol, resulting in a formula of $\FPC$. Second, using the algorithms from
%   the inductive hypothesis' on sub-formulas, producing appropriate families of
%   circuits computing each sub-formula, and the known circuit-translation for
%   formulas of $\FPC$, in order to to produce an appropriate family of circuits
%   computing the operation on these sub-formulas. Third, using the
%   concatenation operation to combine these circuit families and two final
%   operations in order to ensure the family has the required properties.
  
%   This same approach can be used for to handle many other cases. For
%   matrix-circuit-translatable $\phi, \phi_1, \phi_2 \in \FPR[\tau]$ similar
%   constructions can be used to prove that if $\theta(\vec{x}) \in FPR[\tau]$
%   is equal to $\phi_1(\vec{x}) \lor \phi_2(\vec{x})$, $\neg \phi(\vec{x})$,
%   $\forall y. \phi (\vec{x}, y)$ or $\exists y. \phi (\vec{x}, y)$ then
%   $\theta(\vec{x})$ is matrix-circuit-translatable.

%   Suppose $\theta(\vec{x}) = \lfp{V, \vec{y}}{\phi(\vec{x}, \vec{y},
%   V)}(\vec{x})$ for some matrix-circuit-translatable formula $\phi(\vec{x},
%   \vec{y}) \in FPR[\tau \uplus \{V\}]$ and $k$-ary relation symbol $V$. Let
%   $n$ be a natural number. We construct $C^{\theta}_n$ as follows. We have
%   that we may efficiently compute $C^{\phi}_n$. For each $i \in [n^k]$ we
%   construct a circuit $C^i = \langle G^i, \Omega^i, \Sigma^i, \Lambda^i, L
%   \rangle $ as follows. Let $C^0$ be a circuit consisting of exactly $n^k$
%   gates, such that each gate is a constant $0$ gate and each gate is an output
%   gate. Let $R$ be a relation symbol in $\tau$. For each $i > 0$ let $C^i :=
%   \op{concatinate}(C^{\phi}_n, (C^{i-1}_n), (V), R)$ be $C^{\phi}_n$ but with
%   all relational gates labelled by the symbol $V$ replaced with the constant
%   $0$. Since $C^1$ and $C^\phi_n$ are symmetric and have unique labels, and
%   the operation $\op{concatinate}$ preserves the properties of symmetric and
%   unique labels, it follows by induction that for each $i \geq 1$, $C^i$ is a
%   symmetric rank-circuit with unique labels. It follows that $C^{\theta}_n :=
%   C^{n^k}$ is a symmetric rank-circuit and has unique labels. Moreover, since
%   the least-fixed-point operator must converge in at most $n^k$ steps, this
%   construction can be implemented so as to run in time polynomial in $n$. The
%   construction also guarantees that $(C^{\theta}_n)_{n \in \nats}$ computes
%   the same query as $\theta(\vec{x})$.

%   The result in \cite{} establishes that for every formula $\theta(\vec{x})$
%   containing number-terms there is a $P$-uniform family of formulas
%   $(\theta_n(\vec{x}))_{n \in \nats}$ containing counting quantifiers and no
%   number-terms, and such that for all $n \in \nats$, $\theta(\vec{x})$ and
%   $\theta_n(\vec{x})$ are equivalent on structures of size $n$.
  
%   %   Suppose $\theta(\vec{x}) = \lfp{V, \vec{y}}{\phi(\vec{x}, \vec{y},
%   %   V)}(\vec{x})$ for some matrix-circuit-translatable formula
%   %   $\phi(\vec{x},
%   %   \vec{y}) \in FPR[\tau \uplus \{V\}]$ and $\vert y \vert$-ary relation
%   %   symbol
%   %   $V$. Let $n$ be a natural number. We now construct $C^{\theta}_n$. We
%   %   have
%   %   that we may efficiently compute $C^{\phi}_n$. For each $i \in [n^k]$ we
%   %   construct a circuit $C^i = \langle G^i, \Omega^i, \Sigma^i, \Lambda^i, L
%   %   \rangle $ as follows. Let $C^1$ be $C^{\phi}_n$ but with all relational
%   %   gates
%   %   labelled by the symbol $V$ replaced with the constant $0$. For each
%   %   $i>1$ we
%   %   construct $C^{i}$ by `gluing' $C^{i-1}$ into $C^\phi_n$, producing
%   %   $C^i$.
%   %   Set
%   %   $C^{\theta}_n := C^{n^k}$. Since $C^1$ and $C^\phi_n$ are symmetric and
%   %   have
%   %   unique labels, by induction for each $i > 1$ $C^i$ is symmetric and has
%   %   unique
%   %   labels. It follows that $C^{\theta}_n$ is symmetric and has unique
%   %   labels.
%   %   Moreover, since the least-fixed-point operator must converge in at most
%   %   $n^k$
%   %   steps, this algorithm runs in time polynomial in $n$ and the family
%   %   $(C^{\theta}_n)_{n \in \nats}$ computes the same query as
%   %   $\theta(\vec{x})$.

%   %   The result in \cite{} establishes that for every formula
%   %   $\theta(\vec{x})$
%   %   containing number-terms there is a $P$-uniform family of formulas
%   %   $(\theta_n(\vec{x}))_{n \in \nats}$ containing counting quantifiers and
%   %   no
%   %   number-terms, and such that for all $n \in \nats$, $\theta(\vec{x})$ and
%   %   $\theta_n(\vec{x})$ are equivalent on structures of size $n$.

%   %   gives for each $\theta (\vec{x}) \in FPC[\tau]$ a $P$-uniform family of
%   %   formulas $(\theta_n)_{n \in \nats}$ such that $\theta_n(\vec{x})$ is in
%   %   the
%   %   extension of fixed-point logic with counting quantifiers and is
%   %   equivalent
%   %   to
%   %   $\theta(\vec{x})$ on structures of size $n$. Similarly, it can be shown
%   %   that
%   %   for $\theta (\vec{x}) \in FPR[\tau]$ there exists an algorithm that
%   %   takes as
%   %   input a natural number $n$ and outputs a formula $\theta_n(\vec{x})$
%   %   with
%   %   counting quantifiers and no number terms which is equivalent to
%   %   $\theta(\vec{x})$ for structures of size $n$ and does not contain any
%   %   number
%   %   terms. Moreover, this algorithm runs in time polynomial in $n$.

%   Thus, in order to handle the number-term case, it is sufficient to show that
%   if $\phi(\vec{x}) \in \FPR[\tau]$ is circuit-translatable then
%   $\theta(\vec{x}) := C^{k}y. \phi(\vec{x}, y)$ is
%   matrix-circuit-translatable. A similar construction as for the universal and
%   existential quantifier gives the required algorithm.

%   The result in \cite{} establishes that for every formula $\theta(\vec{x})
%   \in \FPR[\tau]$ containing rank operators, there exists an algorithm that
%   takes as input a natural number $n$ and outputs a formula
%   $\theta_n(\vec{x})$ with rank quantifiers and no rank operators such that
%   $\theta(\vec{x})$ and $\theta_n(\vec{x})$ are equivalent on structures of
%   size $n$. It is thus sufficient to prove that, for
%   matrix-circuit-translatable $\phi(\vec{z}, \vec{y}, \vec{x}) \in \FPR[\tau]$
%   is, a prime $p$, and a natural number $r$, $\theta(\vec{x}) := \rank^{\leq
%   r}_p \vec{z} \vec{y}. \phi(\vec{z}, \vec{y}, \vec{x})$ is
%   circuit-translatable. We define an algorithm that takes as input a natural
%   number $n$ outputs the required circuit $C^{\theta}_n$.

%   From the inductive hypothesis we may efficiently compute $C^{\phi}_n =
%   \langle G^{\phi}, \Omega^{\phi}, \Sigma^{\phi}, \Lambda^{\phi}, L^{\phi}
%   \rangle$. Let $k:= \vert \vec{x} \vert$, $k_1 : = \vert \vec{z} \vert$ and
%   $k_2 := \vert \vec{y} \vert$. Let $R_\phi$ be a $(k_1 + k_2 + k)$-ary
%   relation symbol not in $\tau$. Let $\theta'(\vec{x}) = \rank^{\leq r}_r :=
%   \vec{z}, \vec{y}. \phi (\vec{z}, \vec{y}, \vec{x})$. We now define a
%   $(\mathbb{B}_{\rank}, \{ R_{\phi} \})$-circuit $C^{\theta'}_n:= \langle
%   G^{\theta'}, \Omega^{\theta'}, \Sigma^{\theta'}, \Lambda^{\theta'},
%   L^{\theta'}\rangle$ as follows. Let $G_1 := \{g_{\rank, \vec{c}} : \vec{c}
%   \in [n]^k\}$ and $G_2 : = \{ g_{R_{\phi}, \vec{a}, \vec{b}, \vec{c}} :
%   \vec{a} \in [n]^{k_1}, \vec{b} \in [n]^{k_2}, \vec{c} \in [n]^{k}\}$.
  
%   \begin{itemize}
%     \setlength\itemsep{0mm}
%   \item Let $G^{\theta'} := G_1 \uplus G_2$,
%   \item $\Omega^{\theta'}$ be an injection from $[n]^k$ to $G'$ defined by
%     $\Omega^{\theta'}(\vec{c}) = g_{\rank, \vec{c}}$,

%   \item $\Sigma^{\theta'} (g) := rank^r_p$ if $g \in G_1$ and
%     $\Sigma^{\theta'}(g) = R_\phi$ if $g \in G_2$,
%   \item For each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$ let
%     $\Lambda^{\theta'} (\vec{a}, \vec{b}, \vec{c}) := g_{R_{\phi}, \vec{a},
%     \vec{b}, \vec{c}}$, and

%   \item For each gate $g_{\rank, \vec{a}} \in G_1$ let $L(g_{\rank, \vec{a}}):
%     [n]^{k_1} \times [n]^{k_2} \rightarrow G^{\theta'}$ be defined by
%     $L(g_{\rank, \vec{c}})(\vec{a}, \vec{b}) := g_{R_\phi, \vec{a}, \vec{b},
%     \vec{c}}$ for each $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.
%   \end{itemize}
 
%   It is easy to see that both $C^{\theta'}_n$ (and $C^{\phi}_n$) are symmetric
%   rank-circuits with unique labels. Let $R$ be a relation symbol in $\tau$.
%   Let $D^{\theta}_n := \op{compose}(C^{\theta'}_n, (C^{\phi}_n), (R_\phi),
%   R)$. Let $H$ consist of all non-output gates in $D^{\theta}_n$. From the
%   inductive hypothesis all gates in $H$ have unique labels. Let $C^{\theta}_n
%   := \op{make-injective-all}(\op{merge-all}(D^{\theta}_n, H))$.

%   Since $C^{\theta'}_n$ and $C^{\phi}_n$ are symmetric, have unique labels,
%   and the input tuples of relations and circuits are singletons, it follows
%   that $D^{\theta}_n$ is a symmetric rank-circuit with unique labels. It can
%   be shown that the construction of $C^{\theta}_n$ from the natural number $n$
%   can be implemented as an algorithm running in time polynomial in $n$. The
%   construction ensures that the circuit family $(C^{\theta}_n)_{n \in \nats}$
%   computes the same query as the one defined by $\theta(\vec{x})$.
 
%   It remains only to note that any atomic formula of $\FPR[\tau]$ is trivially
%   matrix-circuit-translatable. The result thus follows.
% \end{proof}
  
% \langle G', \Omega', \Sigma', \Lambda', L'\rangle$, where $R$ is a $(k_1 + k_2
% +k)$-arity relation symbol. Let $G_1' := \{g_{\rank, \vec{c}} : \vec{c} \in
% [n]^k\}$ and $G_2' : = \{ g_{R, \vec{a}, \vec{b}, \vec{c}} : \vec{a} \in
% [n]^{k_1}, \vec{b} \in [n]^{k_2}, \vec{c} \in [n]^{k}\}$.

% \begin{itemize}
%   \setlength\itemsep{0mm}
% \item Let $G' := G_1' \uplus G_2'$,
% \item $\Omega'$ be an injection from $[n]^k$ to $G'$ defined by
%   $\Omega'(\vec{c}) = g_{\rank, \vec{c}}$,

% \item $\Sigma' (g) := rank^r_p$ if $g \in G_1'$ and $\Sigma'(g) = R$ if $g \in
%   G_2'$,
% \item For each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$ let
%   $\Lambda' (\vec{a}, \vec{b}, \vec{c}) := g_{R, \vec{a}, \vec{b}, \vec{c}}$,
%   and

% \item For each gate $g_{\rank, \vec{a}} \in G_1'$ let $L(g_{\rank, \vec{a}}):
%   [n]^{k_1} \times [n]^{k_2} \rightarrow G'$ be defined by $L(g_{\rank,
%   \vec{c}})(\vec{a}, \vec{b}) := g_{R, \vec{a}, \vec{b}, \vec{c}}$ for each
%   $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.

% \end{itemize}
% Let $C^{\theta}_n$ be the result of `gluing' $C^{\phi}_n$ into $C'$.

% It is easy to see that both $C'$ and $C^{\phi}_n$ are symmetric rank-circuits
% with unique labels. Thus $C^{\theta}_n$ is a symmetric rank-circuit with
% unique labels. The construction of $C'$, and hence $C^{\theta}_n$, can be
% implemented so as to run in time polynomial in $n$. The construction ensures
% that the circuit family $(C^{\theta}_n)_{n \in \nats}$ computes the same query
% as the one defined by $\theta(\vec{x})$.

% It remains only to note that any atomic formula of $\FPR[\tau]$ is trivially
% circuit-translatable. The result thus follows.
% \end{proof}

% such that for any structure $\mathcal{A}$ of size $n$ and an assignment $$ to
% the tuple of variables $\vec{x}$

% is symmetric and has unique labels.

% an equality between two numerical terms or an application of the
% least-fixed-point operator,



% it follows from Lemma \ref{}, that the syntactic equivalence relation on $G_1
% \uplus G_2$ can be efficiently computed.

% Note that the construction guarantees that $C^{\theta}_n$ is symmetric.
% Moreover, since the only gates in $C^{\theta}_n$ are either output gates or
% gates


% Suppose $\theta(\vec{x})$ is of the form $\phi_1(\vec{x}) \land
% \phi_2(\vec{x})$, $\phi_1(\vec{x})\lor \phi_2(\vec{x})$, $\neg \phi(\vec{x})$,
% $\thr_k(y).\phi(\vec{x}, y)$, $\forall y. \phi (\vec{x}, y)$, $\exists y. \phi
% (\vec{x}, y)$, an equality between two numerical terms or an application of
% the least-fixed-point operator, and each of these sub-formulas is
% $(\mathbb{B}, \tau)$-circuit-translatable} then $\theta(\vec{x})$ is
% $(\mathbb{B}, \tau)$-circuit-translatable}. This follows from the following
% construction. Let $n \in \nats$. We take derive the formula $\theta'(\vec{x})$
% from $\theta(\vec{x})$ by replacing each sub-formula $\phi(\vec{z})$ with the
% formula $R_\phi(\vec{z})$ (adding in some new relational symbol $R_\phi$). We
% may then translate $\theta'(\vec{x})$ into a $P$-uniform family of symmetric
% circuits with threshold and unique labels $(C^{\theta'}_n)_{n \in \nats}$. For
% each $n$ we then replace the relational gates in $C^{\theta'}_n$ labelled by
% $R_\phi$ with the circuit $C^{\phi}_n$ (that is, we add in the entire circuit
% $C^\phi_n$ and replace each relational gate $g$ labelled by $R_\phi$ such that
% $\vec{a}:= \Lambda(\vec{a})$ with with the output gates of $C^{\phi}_n$ such
% that if $g$ is a relational gate computing $R_\phi(\vec{a})$ then $g$ is
% replaced by the gate $\Omega^{-1}(\vec{a})$ in $C^{\phi}_n$). We call this new
% circuit $C^\theta_n$. It is easy to see that this circuit is symmetric. To see
% that it has unique labels, notice that we need only check

% , if $L;$ $L'(g) := L(g)$ for all $g \in G' \cap G$ and for all $g \in H$
% $L'(H) := L(g)$ if $g \in H$



% \begin{lem}
%   We say a
% \end{lem}

% We should like to argue that for any $\theta(\vec{x}) \in \FPR[\tau]$ if every
% sub-formula of $\theta(\vec{x})$ is $(\mathbb_{\mat}, \tau)$-circuit
% translatable then $\theta(\vec{x})$ is $(\mathbb_{\mat}, \tau)$-circuit
% translatable. The existence of the desired translation then follows by
% induction on the structure of the formula.

% It is easy to see that if $\theta(\vec{x})$ is of the form $\phi_1(\vec{x})
% \land \phi_2(\vec{x})$, $\phi_1(\vec{x})\lor \phi_2(\vec{x})$, $\neg
% \phi(\vec{x})$, $\thr_k(y).\phi(\vec{x}, y)$, $\forall y. \phi (\vec{x}, y)$,
% $\exists y. \phi (\vec{x}, y)$, an equality between two numerical terms or an
% application of the least-fixed-point operator, and each of these sub-formulas
% is $(\mathbb{B}, \tau)$-circuit-translatable} then $\theta(\vec{x})$ is
% $(\mathbb{B}, \tau)$-circuit-translatable}. This follows from the following
% construction. Let $n \in \nats$. We take derive the formula $\theta'(\vec{x})$
% from $\theta(\vec{x})$ by replacing each sub-formula $\phi(\vec{z})$ with the
% formula $R_\phi(\vec{z})$ (adding in some new relational symbol $R_\phi$). We
% may then translate $\theta'(\vec{x})$ into a $P$-uniform family of symmetric
% circuits with threshold and unique labels $(C^{\theta'}_n)_{n \in \nats}$. For
% each $n$ we then replace the relational gates in $C^{\theta'}_n$ labelled by
% $R_\phi$ with the circuit $C^{\phi}_n$ (that is, we add in the entire circuit
% $C^\phi_n$ and replace each relational gate $g$ labelled by $R_\phi$ such that
% $\vec{a}:= \Lambda(\vec{a})$ with with the output gates of $C^{\phi}_n$ such
% that if $g$ is a relational gate computing $R_\phi(\vec{a})$ then $g$ is
% replaced by the gate $\Omega^{-1}(\vec{a})$ in $C^{\phi}_n$). We call this new
% circuit $C^\theta_n$. It is easy to see that this circuit is symmetric. To see
% that it has unique labels, notice that we need only check


% We solve this problem completely for one case and argue that the other cases
% follow similarly. Suppose $\theta (\vec{x}) = \phi_1(\vec{x}) \land
% \phi_2(\vec{x})$. We now describe an algorithm that takes in $n\in \nats$ and
% outputs a formula $C^\theta_n$ with the required properties. We first
% introduce two relation symbols $R_{\phi_1}$ and $R_{\phi_2}$ not in $\tau$ and
% with arity $\vert\vec{x}\vert$. We define $\theta' (\vec{x}) =
% R_{\phi_1}(\vec{x}) \land R_{\phi_2}(\vec{x})$ and compute the associated
% symmetric threshold circuit with unique labels $C^{\theta'}_n$. Similarly, for
% each $i\ \in \{1,2\}$ we may compute the symmetric $(\mathbb{B},
% \tau)$-circuit with unique labels corresponding to $\phi_i$ that takes in
% inputs of size $n$, $C^{\phi_i}_n = \langle G_i, \Omega_i, \Sigma_i Lambda_i,
% L_i \rangle$ algorithms given by the inductive hypothesis. We then construct
% $C^{\theta}_n$ by inserting into $C^{\theta'}_n$ the circuits $C^{\phi_1}_n$
% and $C^{\phi_2}_n$ (that is, taking a disjoint union of the sets of gates and
% the functions that define each circuit -- with the exception of $\Omega$ which
% is specified by $C^{\theta'}_n$ alone). Then for all $i \in \{1,2\}$ and each
% relational gate $g$ in $C^{\theta}_n$ such that $\Sigma(g) = R_{\phi_i}$ we
% replace $g$ with $\Omega_i(\Lambda_i(g))$. Since $C^{\phi_1}_n$ and
% $C^{\phi_2}_n$ have unique labels, it follows from Lemma \ref{} that we can
% efficiently decide if any two gates $g_1, g_2 \in G_1 \uplus G_2$ are
% syntactical equivalent. For each pair of gates $g_1, g_2$ in the range of
% $\Omega_1 \uplus \Omega_2$ we check if $g_1 \equiv g_2$, and if so we merge
% them.

% The resultant circuit $C^{\theta}_n$ is clearly a symmetric $(\mathbb{B},
% \tau)-circuit$-circuit. Moreover, it is easy to see that if all pairs of gates
% in the range of $\Omega_1 \uplus Omega_2$ are not syntactical equivalent $g$
% is a gate such that $h_1, h_2 \in H_g$ are syntactically equivalent then . it
% has unique labels (as the only point where two input gates could be equivalent

% we can from Lemma \ref{} that we can efficiently decide if two any two gates
% from the union of these circuits are syntactical equivalent. If any of their
% output gates are syntactically equivalent, merge these gates. This new circuit
% has disjoint


% we replace the relational gate $g$ in $C^{\theta'}_n$ such that $\Sigma(g) =
% R_\phi$ and $\Lambda(g) = \vec{a}$ with the circuit $C^\phi_n$ $\vec{a}$, an
% $\arty(R_\pi)$ each relational gate $R_\phi(\vec{a})$ in the circuit
% $C^{\theta'}_n$


% It remains to show that for any $k \in \nats$ and formula $\phi \in
% \FPR[\tau]$ such that $\phi$ formula of the form $\theta (\vec{z}): = [rank
% (\vec{x}, \vec {\nu} \leq \vec{t}, \vec{y}\vec{\mu} \leq \vec{s}, \pi \leq r).
% \phi(\vec{x}, \vec{nu}, \vec{y}, \vec(mu), \vec{s}, \vec{z})] \leq k$ there is
% an equivalent $P$-uniform family of symmetric rank-circuits with unique labels
% $(C_n)_{n \in \nats}$ that compute the same query as $\theta$.


% \begin{lem}
%   Let $\tau$ be a relational vocabulary and let $\phi(\vec{x})$ be a formula
%   of $\FPR[\tau]$. There is an algorithm that takes as input a natural number
%   $n$ and outputs a formula $\phi_n$ such that $\phi_n$ contains no rank
%   operators or counting terms and for any $\tau$-structure $\mathcal{A}$ of
%   size $n$ and $\vert \vec{x} \vert$-tuple of elements $\vec{a}$ from the
%   universe of $\mathcal{A}$, $\mathcal{A}\models \phi[\vec{a}]$ if, and only
%   if, $\mathcal{A}\models \phi_n[\vec{a}]$. Moreover, this algorithm runs in
%   time polynomial in $n$.
% \end{lem}

% \begin{thm}
%   Let $\tau$ be a relational vocabulary and let $\phi$ be a formula of
%   $\FPR[\tau]$. There is an algorithm that takes as input a natural number $n$
%   and outputs a symmetric matrix-circuit $C_n$. This algorithm runs in time
%   polynomial in $n$. Moreover, the query computed by the circuit family
%   $(C_n)_{n \in \nats}$ and the query defined by the formula $\phi$ are equal.
% \end{thm}
% \begin{proof}
%   We describe a transformation inductively on the structure of the formula.
%   This procedure can then be implemented algorithmically using recursion.
  
%   If $\phi(\vec{a})$ is an atomic formula
  
% \end{proof}

% We define this transformation by recursion on the structure of the formula and
% note that and note that such a transformation can be implemented so as to run
% in time polynomial in $n$.

% Let $\phi$ be a formula




% \begin{thm}
%   Formulas of $\FPR$ can be translated into symmetric matrix-circuits
% \end{thm}
% \begin{proof}
%   The idea here is to do exactly the same thing as for FPC formulas except
%   when we arrive at a rank quantifier we `tag' each formula with
% \end{proof}
 \end{document}