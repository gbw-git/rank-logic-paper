\documentclass[../paper.tex]{subfiles}
\begin{document}
In this section we first introduce a number of useful polynomial-time computable
functions which define transformations on circuits. In the second subsection we
use these functions to define a transformation that takes $\FPR$-formulas to
equivalent families of transparent symmetric rank-circuits.

\subsection{Algorithms for Circuits}
In order to simplify the presentation of the translation between $P$-uniform
families of circuits and formulas of $\FPR$, as well as the proofs of other
results (see Lemma~\ref{lem:transparent-unique}), we define a number of
often-used polynomial-time computable circuit transformations.

We first define the function $\op{merge}$, which maps a circuit and a set of
syntactically-equivalent gates to a circuit formed by combining those gates into
a single gate.

\begin{definition}
  Let $C := \langle G, \Omega, \Sigma , \Lambda, L \rangle$ be a circuit and $H
  := \{h_1, \ldots, h_p\}$ be a set of syntactically equivalent gates. We let
  $\op{merge}(C, H) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{h_2, \ldots, h_p\}$,
  \item $\Omega' = \Omega$,
  \item $\Sigma' = \restr{\Sigma}{G'}$,
  \item $\Lambda' = \Lambda$, and
  \item For all $g \in G'$ and $x \in Ind(g)$ if $L(g) (x) \in H$ then $L'(g)(x)
    = h_1$ and if $L(g)(x) \notin H$ then $L'(g)(x) = L(g)(x)$.
  \end{itemize}
\end{definition}

It can be shown that $\op{merge}$ can be computed in time polynomial in the size
of the input circuit. We note that the input and output circuits compute the
same function. Moreover, if the input circuit is symmetric (resp. has unique
labels, is transparent) then the output circuit will also be symmetric (resp.
have unique labels, transparent).

We now define the function $\op{merge-all}$ which maps a circuit and a set of
gates to a new circuit formed by applying $\op{merge}$ to the
syntactic-equivalence classes of the set of gates.

\begin{definition}
  \label{def:merge-all}
  The function $\op{merge-all}$ maps a circuit $C$ and a set of gates $H$ to a
  circuit $\op{merge-all}(C, H) := C'$, where $C'$ is defined as follows. Let
  $H_1, \ldots, H_p$ be the syntactic equivalence classes of $H$, and let $C'$
  be defined from $C$ by successively applying $\op{merge}$ to each of these
  equivalence classes.
\end{definition}

We can compute $\op{merge-all}$ using the following algorithm. Let $(C, H)$ be a
tuple in the domain of $\op{merge-all}$. We assume a reasonable encoding of the
circuit, and note that any such encoding induces a linear order on the
structure. Let $H_1, \ldots, H_p$ be the syntactic-equivalence classes of $H$
linearly ordered such that for all $i, j \in [p]$ if $i \leq j$ the height of
the gates in $H_i$ is less than or equal to the height of the gates in $H_j$.
Let $C'$ be the result of successively executing the algorithm for $\op{merge}$
on each such equivalence class in order.

It is worth noting that for an input tuple $(C, H)$, if follows from
Lemma~\cite{lem:unique-labels-syntactic-equiv} that if $H$ has unique labels
then the syntactic-equivalence relation on $H$ can be computed in time
polynomial in the size of $C$. Thus, if each gate in $H$ has unique labels, it
can be shown that $\op{merge-all}$ can be computed in time polynomial in the
size of the input circuit.

As in the case of $\op{merge}$, the function $\op{merge-all}$ preserves
symmetry, unique labels and the ensures that the input and output circuits
compute the same function. Let be a circuit $C$ a circuit and $H$ a set of gates
in $C$ with unique labels. Then if $g$ is a gate in both $C$ and $C' :=
\op{merge-all}(C, H)$, and all of the children of $g$ in $C$ are in $H$, then no
two distinct children of $g$ in $C'$ are syntactically-equivalent. However, we
have no guarantee that $g$ will have unique labels in $C'$ as we have no
guarantee that $L'(g)$ is injective.

The now define the function $\op{make-injective}$ that maps a circuit and a
symmetric gate to an equivalent circuit containing all the same gates as the
input circuit but such that the specified gate now has injective labels.

\begin{definition}
  \label{def:make-injective}
  The function $\op{make-injective}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ and a gate $h \in G$ to the circuit
  $\op{make-injective}(C, h) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, defined as follows. Let $c = \max \{\vert L(g)^{-1}(h)\vert : g \in
  W(h, \cdot)\}$. If $c = 1$ then $C' := C$. If $c > 1$ then $C'$ is defined
  such that
  \begin{itemizens}
  \item $G' = G \uplus \{h_2, \ldots, h_{c-1}\}$,
  \item $\Omega' = \Omega$,
  \item For each $g \in G$ let $\Sigma' (g) = \Sigma(g)$, otherwise let
    $\Sigma'(g)$ be a single-input $\AND$-gate.
  \item $\Lambda'= \Lambda$
  \item For each $g \in G'$ if $g \in G \setminus W(h, \cdot)$ then $L'(g) =
    L(g)$. If $g \in W(h, \cdot)$ let $\{x_1, \ldots, x_k\} := L(g)^{-1}(h)$ and
    for each $x \in \ind(g)$ if $L(g)(x) \neq h$ then $L'(g)(x) = L(g)(x)$ else
    if $x = x_i \in L(g)^{-1}(h)$ then let $L'(g)(x) = h_i$.
  \end{itemizens}
\end{definition}

It can be shown that $\op{make-injective}$ can be computed by an algorithm
running in time polynomial in the size of the input circuit. Moreover, the input
and output circuits of this operation compute the same function.

We now define the function $\op{make-injective-all}$ that maps a circuit to an
equivalent circuit such that every symmetric gate now has injective labels.

\begin{definition}
  The function $\op{make-injective-all}$ maps a circuit $C := \langle G, \Omega,
  \Sigma , \Lambda, L \rangle$ to a circuit $\op{make-injective}(C) := C' :=
  \langle G', \Omega', \Sigma', \Lambda', L' \rangle$ defined as follows.

  Let $F$ be a function that maps an ordered circuit $C*$ to the circuit
  $\op{make-injective}(C*, h)$, where $h$ is the topologically first gate such
  that there exists a gate $g$ in $C*$ where $h$ is a child of $g$ and $\vert
  L*(g)^{-1}(h) \vert > 1$. Let $(C^0, C^1, \ldots)$ be a sequence of circuits
  where $C^0 := C$ and for $i > 1$, $C^i := F(C^{i-1})$. It can be shown that
  this sequence converges after at most $\vert C \vert$ many steps. Let $C'$ be
  the limit of this sequence.
\end{definition}

Since $\op{make-injective}$ can be computed in polynomial time, and the number
of iterations required to converge to the limit in the above definition is
bounded by the size of the circuit, it can be shown that
$\op{make-injective-all}$ can be computed in time polynomial in the size of the
input circuit. Furthermore, we note that $\op{make-injective-all}$ preserves
symmetry, rigidity and unique labels. Moreover, the input and output circuits
compute the same function.

We now define the function $\op{insert}$ that maps two circuits to a circuit
formed by inserting the gates of the first circuit into the second circuit.

\begin{definition}
  The function $\op{insert}$ maps a $(\mathbb{B}_1, \tau_1)$-circuit $C^1 :=
  \langle G_1, \Omega_1, \Sigma_1 , \Lambda_1, L_1 \rangle$ and a
  $(\mathbb{B}_2, \tau_2)$-circuit $C^2 := \langle G_2, \Omega_2, \Sigma_2 ,
  \Lambda_2, L_2 \rangle$ to a $(\mathbb{B}_1 \cup \mathbb{B}_2, \tau_1 \uplus
  \tau_2)$-circuit $\op{insert}(C^1, C^2) := C := \langle G, \Omega, \Sigma ,
  \Lambda, L \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G = G_1 \uplus G_2$,
  \item $\Omega = \Omega_2$,
  \item $\Sigma = \Sigma_1 \uplus \Sigma_2$,
  \item $\Lambda = \Lambda_1 \uplus \Lambda_2$, and
  \item $L = L_1 \uplus L_2$.
  \end{itemize}
\end{definition}

It can be shown that $\op{insert}$ can be be computed in time polynomial in the
size of the input circuits. Moreover, if the input circuits are symmetric then
the output circuit is symmetric.

We now define the function $\op{replace}$ that maps a circuit $C$ and a pair of
gates $(g_1, g_2)$ in $C$ to a circuit $C'$ formed by replacing $g_1$ with $g_2$
in $C$.

\begin{definition}
  The function $\op{replace}$ maps a circuit $C = \langle G, \Omega, \Sigma,
  \Lambda, L\rangle$ and a pair of gates $(g_1, g_2)$ in $C$ to a circuit
  $\op{replace}(C, g_1, g_2) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$, where
  \begin{itemize}
    \setlength\itemsep{0mm}
  \item $G' = G \setminus \{g_1\}$,
  \item $\Omega'$ is an function from the domain of $\Omega$ to $G'$ such that
    for each $\vec{a} \in \dom(\Omega)$ if $\Omega(\vec{a}) = g_1$ then
    $\Omega'(\vec{a}) = g_2$ and otherwise $\Omega'(\vec{a}) = \Omega(\vec{a})$.
  \item $\Sigma' = \restr{\Sigma}{G'}$
  \item $\Lambda' = \restr{\Lambda}{G'}$
  \item For each $g \in G'$ and each $x \in \ind(g)$ if $L(g)(x) = g_1$ then
    $L'(g)(x) = g_2$ and if not then $L'(g)(x) = L(g)(x)$.
  \end{itemize}
\end{definition}

It can be shown that the function $\op{replace}$ can be computed in time
polynomial in the size of the input circuit.

We now define the function $\op{tag}$ that maps a circuit, a relation symbol, a
gate in that circuit, and a tuple to a circuit computing the same function as
the input circuit but with an additional gadget, constructed using the gates
labelled by the given relation symbol and tuple, marking the designated gate.
The intuition is that this marking helps to distinguish a gate, and is used as a
step to ensure that a circuit has unique labels.

\begin{definition}
  The function $\op{tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle G,
  \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a gate $g \in G$, and a tuple $\vec{a} \in [n]^k$ for some $k$ to a
  circuit $\op{tag}(C, R, g, \vec{a}) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$, such that $G' = G \uplus \{\land_g,
  \land_{g'}, \land_1, \ldots , \land_k\}$, $\Omega' = \Omega$, and $\Lambda' =
  \Lambda$. For each $g \in G$ $\Sigma'(g) = \Sigma(g)$. For each $g \in
  \{\land_0, \land_1, \ldots , \land_k \}$, $\Sigma(g)$ is an $\AND$-gate that
  takes in two inputs. $\Sigma(\land_g)$ is an $\AND$-gate that takes in a
  single input, $g$ is the lone input to $\land_g$, and $\land_0$ has as input
  $\land_g$ and $\land_1$. For each $i \in [k-1]$ the inputs of $\land_i$ are
  $\land_{i+1}$ and the gate $g_i \in G'$ such that $\Sigma(g_i) = R$ and
  $\Lambda^{-1}(g_i) = \vec{a}_i$, where $\vec{a}_i$ is the $k$-tuple
  $(\vec{a}(i), \ldots, \vec{a}(i))$. The inputs of $\land_k$ are the constant
  gate $1$ and the gate $g_k$ such that $\Sigma(g) = R$ and $\Lambda^{-1}(g_k) =
  \vec{a}_k$. For each gate $h \in G \setminus \{g\}$ and $x \in \ind(h)$, if
  $L(h)(x) = g$ then $L'(h)(x) = \land_0$, otherwise $L'(h)(x) = L(h)(x)$.
\end{definition}

It can be shown that $\op{tag}$ can be computed in time polynomial in the size
of its input. The input and output circuits compute the same function. Moreover,
if the input circuit has unique labels then the output circuit will have unique
labels. If the input relation symbol is obvious from the context we omit it when
invoking $\op{tag}$.

\begin{definition}
  The function $\op{tag-all}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$ of order $n$, a relation symbol $R \in
  \tau$, a set of gates $H \subseteq G$, and $T := (\vec{a}_h)_{h \in H}
  \subseteq [n]^{k}$ a sequence of tuples indexed by $H$ for some fixed $k$, to
  a circuit $\op{tag-all}(C, R, H, T) := C' := \langle G', \Omega', \Sigma',
  \Lambda', L'\rangle$ of order $n$ defined as follows.

  Suppose there is a linear order on $H$, and write $H = \{h_1, \ldots, h_t\}$.
  Let $C_0 := C$ and for all $i \in [t]$ let $C_i := \op{tag}(C_{i-1}, R, h_i,
  T(h_i))$. Then $C' = C_{t}$.
\end{definition}

It is easy to see that, since $\op{tag}$ can be computed in time polynomial in
the combined size of its inputs, $\op{tag-all}$ can also be computed in time
polynomial in the combined size of its inputs.

We now define the function $\op{compose}$ that maps a circuit and a sequence of
circuits and to a circuit formed by replacing the input gates of the designated
circuit with the output gates of the circuits in the sequence.

\begin{definition}
  The function $\op{compose}$ maps a $(\mathbb{B}, \tau)$-circuit $C := \langle
  G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation sybmols $\tau_R
  := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence of
  circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose}(C,
  \mathcal{C}, \tau_R) := C' := \langle G', \Omega', \Sigma', \Lambda', L'
  \rangle$. Note that all circuits take in structures of size $n$. The circuit
  $C'$ is defined as follows.
  
  Let ${C^0}' := \langle G_0', \Omega_0', \Sigma_0', \Lambda_0', L_0' \rangle :=
  C$, and let $i \in [t]$. Let $D^{i-1}:= \op{insert} (C^i, {C^{i-1}}')$ and
  $G^{i-1}_{R_i}$ be the set of all relational gates in $D^{i-1}$ labelled by
  the relational symbol in $R_i$. Let ${C^{i-1}}' := \langle G_i', \Omega_i',
  \Sigma_i', \Lambda_i', L_i' \rangle$ be the circuit formed from $D^{i-1}$ by
  replacing each gate in $g \in G^{i-1}_{R_i}$ with the gate
  $\Omega_{i}(\Lambda_{i-1}'(g))$ in $D^{i-1}$ (by repeated calls to the
  $\op{replace}$ function). Let $C' = {C^{t}}'$.
\end{definition}

It can be shown that $\op{compose}$ can be computed in time polynomial in the
sum of the sizes of the input circuits. We also note that the size of $C'$ is
less than or equal to the sum of the sizes of the input circuits. Moreover, if
the input circuits are all symmetric then the output circuit will be symmetric.
Also, for an input tuple $(C, \mathcal{C}, \tau_R)$, we have that if $C$ has
symmetric gates and transparent, and all the circuits in $\mathcal{C}$ are
transparent, then $C' := \op{compose}(C, \mathcal{C}, \tau_R)$ is transparent.
If $C$ contains a non-symmetric gates then, as the output gates of the circuits
in $\mathcal{C}$ are no longer labelled as output gates in $C'$, it may be that
some of these gates are syntactically-equivalent in $C'$, resulting in $C'$ not
being transparent.

In certain contexts we are interested composing gates such that if the input
circuits are transparent (resp. have unique labels) then the output circuits
will be transparent (resp. have unique labels). In this case, while composing
the circuits we apply the $\op{tag}$ function to the output gates of the
circuits in the input sequence of circuits. We now define the function
$\op{compose-and-tag}$ that implements this operation.

\begin{definition}
  The function $\op{compose-and-tag}$ maps a $(\mathbb{B}, \tau)$-circuit $C :=
  \langle G, \Omega, \Sigma, \Lambda, L \rangle$, a sequence of relation symbols
  $\tau_R := (R_1, \ldots, R_t)$ such that $\tau_R \subseteq \tau$, a sequence
  of circuits $\mathcal{C} := ( C^1, \ldots, C^t)$, where for each $i \in [t]$,
  $C^i = \langle G_i, \Omega_i, \Sigma_i, \Lambda_i, L_i \rangle$ is a
  $(\mathbb{B}_i, \tau_i)$-circuit, and $\tau_i \not\subset \tau_R$ and $C^i$
  computes a query of arity $\arty(R_i)$ to a circuit $\op{compose-and-tag}(C,
  \mathcal{C}, \tau_R, R) := C'$. The circuit $C'$ is defined as follows. Note
  that all circuits take in structures of size $n$.
  
  Let $D^0 := \op{compose}(C, \mathcal{C}, \tau_R)$. For each $i \in [t]$, let
  $D^{i} := \op{tag-all}(D^{i-1}, R, \img(\Omega^{-1}_i), \Omega^{-1}_i)$. Let
  $C' := D^t$.
\end{definition}

It is easy to see that $\op{compose-and-tag}$ can be computed in time polynomial
in the sun of the sizes of the input circuits. We also have that if the input
circuits are symmetric then the output circuits are symmetric. Furthermore, if
the input sequences of circuits and relations are both singletons, then if the
input circuits are all transparent (resp. have unique labels) then the output
circuit is transparent (resp. have unique labels). We also note that the output
circuit

\begin{definition}
  The function $\op{tag-inputs}$ maps a circuit $C := \langle G, \Omega, \Sigma,
  \Lambda, L \rangle$, a relation symbol $R \in \tau$, and $H \subseteq G$
\end{definition}

\subsection{Translating FPR to Symmetric Matrix Circuits}
In this subsection we translate $\FPR$-formulas into families of transparent
rank-circuits. In particular, we now show that for $\theta(\vec{x}) \in
\FPR[\tau]$ there exists a $P$-uniform family of symmetric rank-circuits
$(C_n)_{n \in \nats}$ such that the query computed by $(C_n)_{n \in \nats}$ is
equal to the query defined by $\theta (\vec{x})$.

We say that a circuit $C$ \emph{translates} a formula $\psi(\vec{x})$ for $n \in
\nats$ if $C$ is a transparent symmetric rank-circuit of order $n$, $C$ is
defined over the same vocabulary as $\psi (\vec{x})$, and $C$ computes the query
defined by $\psi(\vec{x})$ on structures of size $n$. We say a family of
circuits $(C_n)_{n \in \nats}$ \emph{translates} a formula $\psi (\vec{x})$ if
$(C_n)_{n \in \nats}$ is $\PT$-uniform and for all $n \in \nats$, $C_n$
translates $\psi(\vec{x})$ for $n$.

\begin{definition}
	Let $\alpha : X \rightarrow Y$ and $\beta : W \rightarrow Z$. We say that $f$
  is \emph{compatible} with $g$, and we write $f \sim g$, if for all $a \in X
  \cap W$, $f(a) = g(a)$ and for all $a \in X \setminus W$ and $b \in W
  \setminus X$, $f(a) \neq g(b)$.
\end{definition}

We now prove that for every $\FOrk$-formula $\theta(\vec{x})$ and $n \in \nats$
there exists a circuit $C$ that translates $\theta(\vec{x})$ for $n$. The gates
of $C$ are of the form $g_{\psi, \alpha}$, where $\psi(\vec{y})$, a sub-formula
of $\theta(\vec{x})$, and $\alpha$ is an assignment to the free variables of
$\psi$. We then wire up the gates such that $g_{\psi, \alpha}$ is associated
with an appropriate function from the basis, and the children of $g_{\psi,
  \alpha} $ are those gates $g_{\phi, \beta}$, where $\phi$ is an immediate
sub-formula of $\psi$ and $\beta$ is an assignment to the free variables in
$\phi$ that agrees with the assignment $\alpha$. The resultant circuit is
symmetric and has the property that $g_{\psi, \alpha}$ evaluates to one for a
given input structure if, and only if, $\psi$ holds for that structure given the
assignment $\alpha$. However, as stated this construction does not result in a
transparent circuit. In order to ensure that $C$ is also transparent we first
alter $\theta$ by appending to each application of the rank operator a gadget
that ensures that no two children of a rank gate are syntactically-equivalent.
We now formally define this construction and, moreover, provide a bound on the
running time of the algorithm constructing this circuit.

\begin{lem}
  There is an algorithm that takes in a $\FOrk$-formula $\theta(\vec{x})$ and $n
  \in \nats$ and outputs a rank-circuit $C$ that translates $\theta(\vec{x})$
  for $n$. Moreover, there is a polynomial in $p$ such that for an input
  $(\theta(\vec{x}), n)$ the algorithm terminates in at most
  $p(n^{\width(\theta)}\vert \cl{\theta} \vert)$ many steps.
\end{lem}
\begin{proof}
  Let $\tau$ be the vocabulary of $\theta(\vec{x})$. Let $k := \width(\theta)$.
  Suppose $\tau$ is empty. In this case we can evaluate $\theta$ for each
  assignment $\vec{a}$ in a number of steps polynomial in $n^k \vert \cl{\theta}
  \vert$. Let $f : [n]^k \rightarrow \{0,1\}$ be defined such that $f (\vec{a})
  = 1$ if, and only if, $[n] \models \theta[\vec{a}]$. Let $C = \langle G,
  \Sigma, \Omega, \Lambda, L \rangle$, where
  \begin{itemizens}
  \item $G = \{g_0, g_1\} \cup \{g_{\vec{a}} : \vec{a} \in [n]^{k}\}$,
  \item $\Sigma (g_0) = 0$, $\Sigma (g_1) = 1$ and $\Sigma (g_{\vec{a}}) =
    \land[1]$,
  \item $\Omega : [n]^k \rightarrow G$ is defined by $\Omega(\vec{a}) =
    g_{\vec{a}}$ for all $\vec{a} \in [n]^k$,
  \item $\Lambda = \emptyset$,
  \item for $\vec{a} \in [n]^k$, $L(g_{\vec{a}}) : [1] \rightarrow G$ is defined
    by $L(g_{\vec{a}})(1) = g_{f(\vec{a})}$.
  \end{itemizens}
  
  Since $C$ has symmetric gates, $C$ is transparent. Notice that, since
  $\theta(\vec{x})$ defines a query on structures over the empty vocabulary, we
  have for all $\sigma \in \sym_n$, $f(\sigma \vec{a}) = f(\vec{a})$ for all
  $\vec{a} \in [n]^k$. For $\sigma \in \sym_n$, let $\pi_\sigma : G \rightarrow
  G$ be a bijection that fixes the constant gates and such that $\pi_{\sigma}
  (g_{\vec{a}}) = g_{\sigma \vec{a}}$ for all $\vec{a} \in [n]^k$. Then
  $\pi_\sigma \Omega (\vec{a}) = \pi_\sigma g_{\vec{a}} = g_{\sigma \vec{a}} =
  \Omega (\sigma \vec{a})$. It follows that $\pi_\sigma$ is an automorphism of
  the circuit extending $\sigma$. It follows that $C$ is symmetric, and so $C$
  translates $\theta(\vec{x})$ for $n$.

  Suppose $\tau$ is not empty. Let $R \in \tau$. We now construct a $C'$ that,
  but for transparency, translates $\theta(\vec{x})$ at $n$.

  % We first
  % pre-proccess the formula $\theta(\vec{x})$

  % Let $\op{no-op}(y) := (R(y, y) \land (\neg R(y, y)))$. Let $\vec{y} := (y_1,
  % \ldots, y_k)$ be a vector of variables and $\op{add-tag} (\vec{y}) :=
  % \op{no-op}(y_1) \land (\op{no-op}(y_2) \land ( \op{no-op}(y_2) \land (
  % \ldots
  % \land (\op{no-op}(y_k)) \ldots)))$. From $\theta (\vec{x})$ we construct a
  % new
  % formula $\theta' (\vec{x})$ by replacing each sub-formula $\phi(\vec{y})$ of
  % the form $\rank^r_p \vec{w} \vec{z} . \psi$ by the sub-formula $\rank^r_p
  % \vec{w}\vec{z} . ((\forall u . u = u) \land \phi) \land \op{add-tag}(\vec{w}
  % \cup \vec{z})$.

  Fix $n \in \nats$. For each $\psi \in \cl{\theta'}$ let $G_\psi := \{g_{\psi,
    \alpha} : \alpha \in [n]^{\free{\psi}} \}$. Let $G_{\text{sub}} :=
  \bigcup_{\psi \in \cl{\theta}} G_{\psi}$ and $G_c := \{g_0, g_1\}$. Let $G' := G_c \cup
    G_{\text{sub}}$. We define $\Sigma'$, $\Lambda'$ and $L'$ as follows. Let
    $\Sigma' (g_1) = 1$ and $\Sigma' (g_0) = 0$. If $g_{\psi, \alpha} \in G'
    \setminus G_c$.

    \begin{itemizens}
    \item If $\psi$ is of the form $T(\vec{y})$ for some $T \in \tau$, then
      $\Sigma' (g_{\psi, \alpha}) = T$ and $\Lambda_T' (g_{\psi, \alpha}) =
      \alpha \vec{y}$.
    \item If $\psi$ is of the form $(y_1 = y_2)$, then $\Sigma' (g_{\psi,
        \alpha}) = \land[1]$ and $L'(g) : [1] \rightarrow G$ by $L(g)(1) = g_1$
      if $\alpha (y_1) = \alpha (y_2)$ and $L'(g)(1) = g_0$ otherwise.
    \item If $\psi$ is of the form $\rank^r_p \vec{w} \vec{z}. \phi$, let $a =
      n^{\vert \vec{w}\vert}$ and $b = n^{\vert \vec{z}\vert}$, and $\Sigma'
      (g_{\psi, \alpha}) = \rank[a, b]$. Let $L'(g) : [a] \times [b] \rightarrow
      G$ be defined by $L'(g)(i,j) = g_{\phi, \beta}$, where $\beta : \vec{w}
      \cup \vec{z} \cup \vec{y} \rightarrow [n]$ is such that $\alpha \subseteq
      \beta$ and such $\beta \vec{y}$ and $\beta \vec{z}$ are the $i$th and
      $j$th elements of $[n]^{\vert \vec{w} \vert}$ and $[n]^{\vert \vec{z}
        \vert}$ in the lexicographical ordering.
    \item If $\psi$ is of the form $Q z . \phi(\vec{y}, z)$, for $Q \in
      \{\forall, \exists\}$, then if $Q = \forall$ we have $\Sigma' (g_{\psi,
        \alpha}) = \land [n]$, otherwise $\Sigma' (g_{\psi, \alpha}) = \lor
      [n]$. Let $L'(g) : [n] \rightarrow G$ be defined by $L'(g)(i) = g_{\phi,
        \beta_i}$, where $\beta_i \in [n]^{\vec{y} \cup \{z\}}$ and $\alpha
      \subseteq \beta_i$ and $\beta_i (z) = i$.
    \item If $\psi$ has free variables $\vec{y}$ and is of the form $\phi_1
      (\vec{y}_1) \land \phi_2(\vec{y}_2)$, where $\vec{y_1}, \vec{y_2}
      \subseteq \vec{y}$, then $\Sigma'(g_{\psi, \alpha}) = \land[2]$ and $L'(g)
      : [2] \rightarrow G$ is defined by $L'(g)(i) = g_{\phi_i, \beta_i}$ where
      $\beta_i \in [n]^{\vec{y}_i}$ and $\beta_i \subseteq \alpha$ for $i \in
      [2]$. The same approach is used in the disjunctive case.
    \item if $\psi$ is of the form $\neg \phi$ then $\Sigma' (g_{\psi, \alpha})
      = \neg$ and $L'(g): [1] \rightarrow G$, where $L'(g)(1) = g_{\phi,
        \alpha}$.
    \end{itemizens}

    We let $\Omega' : [n]^k \rightarrow G$ be defined by $\Omega' (\vec{a}) =
    g_{\theta, \alpha}$, where $\alpha \vec{x} = \vec{a}$, for all $\vec{a} \in
    [n]^k$. Let $C' := \langle G', \Omega', \Sigma', \Lambda', L' \rangle$. We
    notice that $\vert C' \vert \leq n^{\width(\theta)} \vert \cl{\theta}
    \vert$. It can be shown that $C'$ can be constructed in time bounded by a
    polynomial in the size of $C'$.

    It is obvious that $C'$ has order $n$. Let $\sigma \in \sym_n$. Let
    $\pi_\sigma' : G' \rightarrow G'$ be a defined such that $\pi_{\sigma}' (g)
    = g$ if $g \in G_c$ and $\pi_\sigma'(g_{\psi, \alpha}) = g_{\psi, \sigma
      \alpha}$ for all $\psi \in \cl{\theta}$ and $\alpha \in n^{\free(\psi)}$.
    It can be seen that $\pi_\sigma$ is an automorphism of $C'$ extending
    $\sigma$. It follows that $C'$ is symmetric.

    If $C'$ contains no rank gates then output $C := C'$. Suppose $C'$ contains
    at least one rank-gate. Let $\psi \in \cl{\theta}$, and suppose $\psi
    (\vec{y}) := \rank^r_p \vec{w} \vec{z}. \phi$. Let $T_{\psi} : G_{\psi}
    \rightarrow [n]^{\vert \vec{w} \vert + \vert \vec{z} \vert}$ be defined by
    $T_{\psi} (g_{\psi, \alpha}) = \alpha \vec{y}$ for all $g_{\psi, \alpha} \in
    G_{\psi}$. Let $T$ be the union of all $T_{\psi}$ and $H$ the union of all
    $G_{\psi}$ for all $\psi \in \cl{\theta}$ an application of the rank
    operator. Let $C := \op{tag-all}(C', R, H, T)$. We note that $\op{tag-all}$
    may be computed in time polynomial in the size of the input circuit.

    Let $a \in [n]$ and let $\op{no-op} (a) := R(a, a) \lor (\neg (R(a, a))$.
    For $\psi (\vec{y})$

    Let $(b_1, \ldots, b_m) := \beta (\vec{w} \cup \vec{z})$. The $\op{tag-all}
    function replaces each input $g_{\phi, \beta}$ of the rank gate $g_{\psi,
      \alpha}$ with the circuit $g_{\phi, \beta} \land \op{no-op}(b_1) \land
    (\op{no-op}(b_2) \land ( \op{no-op}(b_2) \land (\ldots \land
    (\op{no-op}(b_m)) \ldots)))$. This construction does not effect the
    evaluation of any rank gate in the cirucit and ensures that no two to
    $g_{\psi,\alpha}$ in $C$ are syntactically-equivilent. 


    $of the form $$R(a, a) \lor (\neg R(a, a))$ that encode the assignment to
    $\vec{w}\cup \vec{z}$.

    We have that $C$ is transparent, has order $n$, and $C$ and $C'$ decide the
    same query. It remains to show that $C$ is still symmetric.

    However, the $\op{tag-all}$ operation adds a tower of tautologies of the
    form $R(a, \ldots, a) \lor (\neg R (a, \ldots, a))$


    Let $g := g_{\psi, \alpha} \in G$ be a rank gate and let $h, h' \in H_g$.
    Suppose $\psi (\vec{y}) := \rank^r_p \vec{w} \vec{z}. \phi$ and $h :=
    g_{\phi, \beta}$ and $h' := g_{\phi, \beta'}$ are syntactically-equivalent.
    From the construction of $\theta'$ we have that $\phi$ must be of a
    particular form. Suppose $\phi = \eta \land \op{add-tag}(\vec{w} \cup
    \vec{z})$. Let $\gamma$ and $\gamma'$ be the restrictions of $\beta$ and
    $\beta'$ to $\vec{w} \cup \vec{z}$, respectively, and let
    $\zeta(\vec{w}\cup\vec{z}) := \op{add-tag}(\vec{w} \cup \vec{z})$. The
    $\op{add-tag} (\vec{w} \cup \vec{z})$


    The structure of this formula gives us that $h$ is syntactically-equivalent
    to $h'$ if, and only if, $g_{\zeta , \beta'}$




    We also note that $C$ has order $n$.


  \end{proof}

\begin{thm}
  For any relational vocabulary $\tau$ and each $\theta(\vec{x}) \in \FPR[\tau]$
  there is a map $n \mapsto C_n$, where $C_n$ is a transparent symmetric
  rank-circuit, and is computable in time polynomial in $n$. The family of
  circuits $(C_n)_{n \in \nats}$ defined by this mapping computes the same query
  as the one defined by $\theta(\vec{x})$.
  \label{thm:translating-formulas-to-circuits}
\end{thm}

\begin{proof}
  We say that a circuit $C$ \emph{translates} a formula $\psi(\vec{x})$ for $n
  \in \nats$ if $C$ is a transparent symmetric rank-circuit of order $n$ and $C$
  computes the query defined by $\psi(\vec{x})$ on structures of size $n$. We
  say a family of circuits $(C_n)_{n \in \nats}$ \emph{translates} a formula
  $\psi (\vec{x})$ if $(C_n)_{n \in \nats}$ is $\PT$-uniform and for all $n \in
  \nats$, $C_n$ translates $\psi(\vec{x})$ for $n$.

  % We have from Anderson and Dawar~\cite{AndersonD17} that for every formula
  % $\phi(\vec{x}) \in \FPC[\tau]$ there is a $\PT$-uniform family of symmetric
  % circuits $(C^{\phi}_n)_{n \in \nats}$ with unique labels and symmetric gates
  % that translates $\phi(\vec{x})$.
  
  Let $\theta(\vec{x}) \in \FPR[\tau]$ and $t := \width (\theta)$. We begin by
  showing that there exists a $P$-uniform family of formulas
  $(\theta(\vec{x}))_{n \in \nats}$ such that for each $n \in \nats$, we have
  $\theta_n(\vec{x}) \in \FOrk[\tau]$, $\width(\theta_n) \leq 4 t$, and
  $\theta_n(\vec{x})$ is equivalent to $\theta(\vec{x})$ on structures of size
  $n$. This result follows from two observations.

  First, using the translation in~\cite{Dawar09logicswith}, we have that for any
  $\phi(\vec{x}) \in \FPR[\tau]$ of the form $\lfp{V, \vec{y}}{\psi(\vec{x},
    \vec{y}, V)}(\vec{x})$ , there is a mapping $n \mapsto \phi_n$, computable
  in time polynomial in both $n$ and the size of $\phi(\vec{x})$ such that for
  all $n \in \nats$, we have $\phi_n(\vec{x}) \in \FOR[\tau]$, $\width (\phi_n)
  \leq 2 \cdot \width (\phi)$, and $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are
  equivalent on structures of size $n$.

  Second, using the translation in~\cite{libkin2004elements}, we have that if
  $\phi (\vec{x}) \in \FOR[\tau]$ is of the form $\rank (\vec{y}\vec{\mu} \leq
  \vec{t}, \vec{z}\vec{\nu} \leq \vec{s}, \pi \leq r) . \psi (\vec{y}\vec{\mu},
  \vec{z} \vec{\nu})$, then there is a mapping $n \mapsto \phi_n$ computable in
  time polynomial in both $n$ and the size of $\phi(\vec{x})$ such that for all
  $n \in \nats$, $\phi_n(\vec{x}) \in \FOrk[\tau]$, $\width(\phi_n) \leq 2 \cdot
  \width(\phi)$, and $\phi_n(\vec{x})$ and $\phi(\vec{x})$ are equivalent on
  structures of size $n$.

  We thus derive the required $\PT$-uniform family $(\theta_n(\vec{x}))_{n \in
    \nats}$ by applying the first translation and then the second. Let $x$ be a
  variable and $R \in \tau$. Let $\op{no-op}(x) := R(x, x) \land (\neg R(x,
  x))$. Let $\vec{x} := (x_1, \ldots, x_k)$ and $\op{add-tag} (\vec{x}) :=
  \op{no-op}(x_1) \land (\op{no-op}(x_2) \land ( \ldots \land (\op{no-op}(x_k))
  \ldots)$. For each $\theta_n (\vec{x})$ we construct a new formula $\theta_n'
  (\vec{x})$ by replacing each sub-formula $\phi(\vec{y})$ of
  $\theta_n(\vec{x})$ of the form $\rank^r_p \vec{w} \vec{z} . \psi$ by
  $\rank^r_p \vec{w}\vec{z} . (\psi \land \op{add-tag}(\vec{w} \cup \vec{z}))$.
  It is easy to see that we can construct $\theta_n'$ from $\theta_n$ in time
  polynomial in $\theta_n$. Moreover, $\theta_n'$ and $\theta_n$ are equivalent
  and have the same width.

  

  
  Fix $n \in \nats$. We now construct a circuit $C_n$ that translates
  $\theta_n'$ (and hence $\theta_n$ and $\theta$) at $n$. For each $\psi \in
  \cl{\theta_n}$ let $G_\psi := \{g_{\psi, \alpha} : \alpha \in
  [n]^{\free{\psi}} \}$. Let $G := \bigcup_{\psi \in \cl{\theta_n}} G_{\psi}$.
  Let $g_{\psi, \alpha} \in G$. We define $\Sigma$, $\Lambda$ and $L$ as
  follows.
  \begin{itemizens}
  \item If $\psi (\vec{y}) = R(\vec{y})$, for some $R \in \tau$, then $\Sigma
    (g_{\psi, \alpha}) = R$ and $\Lambda_R (g_{\psi, \alpha}) = \alpha
    \vec{y})$.
  \item If $\psi (y_1, y_2) = (y_1 = y_2)$, then if $\alpha (y_1) = \alpha
    (y_2)$, $\Sigma (g_{\psi, \alpha}) = 1$, else $\Sigma (g_{\psi, \alpha}) =
    0$.
  \item if $\psi (\vec{y}) = \rank^r_p \vec{w} \vec{z}. \phi$, then $\Sigma ()$
  \end{itemizens}

 
  

  We first consider the base case. Suppose $\psi(\vec{y})$ is an atomic formula.
  Then $\psi(\vec{y}) \in \FPC[\tau]$, and so, using the translation defined by
  Anderson and Dawar~\cite{AndersonD17}, there exists a family of circuits
  $(C^{\psi}_n)_{n \in \nats}$ that translates $\psi(\vec{y})$. Let
  $T_n(\psi(\vec{y})) := C^{\psi}_n$.

  We now consider the conjunctive case. Suppose $\psi(\vec{y})$ is a sub-formula
  of $\theta_n(\vec{x})$ such that $\psi (\vec{y}) = \phi_1(\vec{y}) \land
  \phi_2(\vec{y})$. Let $R_{\phi_1}$ and $R_{\phi_2}$ be two $\vert \vec{y}
  \vert$-ary relation symbols not in $\tau$ and let $\psi' (\vec{y}) :=
  R_{\phi_1}(\vec{y}) \land R_{\phi_2}(\vec{y})$. Then $\psi'(\vec{y}) \in
  \FPC[\tau]$ and so, using the translation defined by Anderson and Dawar, there
  exists a circuit family $(C^{\psi'}_n)_{n \in \nats}$ that translates
  $\psi'(\vec{y})$. Let $T_n(\psi (\vec{y})) := \op{compose}(C^{\psi'}_n, (
  T_n(\phi_1(\vec{y})), T_n(\phi_2(\vec{y}))), (R_{\phi_1}, R_{\phi_2}))$. We
  note that $T_n(\psi(\vec{y}))$ translates $\psi (\vec{y})$ at $n$ if
  $T_n(\phi_1 (\vec{y}))$ and $T_n(\phi_2(\vec{y}))$ translate $\phi_1(\vec{y})$
  and $\phi_2(\vec{y})$ at $n$, respectively.

  The approach used in the conjunctive case can be summarised as follows. Given
  a sub-formula $\psi (\vec{y})$, we construct an auxiliary formula
  $\psi'(\vec{y})$ in which all the sub-formulas of $\psi(\vec{y})$ are replaced
  with relation symbols. We then construct a circuit $C^{\psi'}$ that translates
  $\psi'(\vec{y})$ at $n$ using the translation defined by Anderson and Dawar.
  Finally, we recursively construct circuits that translate the sub-formulas of
  $\psi(\vec{y})$, and compose these circuits with $C^{\psi'}$.
  
  This approach can be used in order to handle every case with the exception of
  rank. In other words, we can use a similar approach to define
  $T_n(\psi(\vec{y}))$ where $\psi(\vec{y})$ is a sub-formula of
  $\theta_n(\vec{x})$ of the form $\phi_1(\vec{y}) \lor \phi_2(\vec{y})$, $\neg
  \phi(\vec{y})$, $\forall z. \phi (\vec{y}, z)$, or $\exists z. \phi (\vec{y},
  z)$.

  We now handle the rank case. The approach is quite similar, except in this
  case we cannot use the translation defined by Anderson and Dawar in order to
  translate the auxiliary formula, and so must define this translation
  explicitly. Moreover, rather than just composing the circuits, we also add a
  small gadget in order to ensure the resultant circuit is transparent.
  
  Suppose $\psi(\vec{z}, \vec{w}, \vec{y})$ is a sub-formula of
  $\theta_n(\vec{x})$ such that $\psi (\vec{y}) = \rank^{\leq r}_p \vec{z},
  \vec{w} .\phi(\vec{z}, \vec{w}, \vec{y})$, for some $p, r \in \nats$ and $p$
  prime. Let $k:= \vert \vec{y} \vert$, $k_1 : = \vert \vec{z} \vert$ and $k_2
  := \vert \vec{w} \vert$. Let $R_\phi$ be a $(k_1 + k_2 + k)$-ary relation
  symbol not in $\tau$. Let $\psi'(\vec{y}) := \rank^{\leq r}_p\vec{z}, \vec{w}.
  R_{\phi} (\vec{z}, \vec{w}, \vec{y})$. Let $G_{\text{out}} := \{g_{\vec{c}} :
  \vec{c} \in [n]^k\}$ and $G_{\text{in}} : = \{ g_{\vec{a}, \vec{b}, \vec{c}} :
  \vec{a} \in [n]^{k_1}, \vec{b} \in [n]^{k_2}, \vec{c} \in [n]^{k}\}$. Let
  $C^{\psi'}_n:= \langle G^{\psi'}, \Omega^{\psi'}, \Sigma^{\psi'},
  \Lambda^{\psi'}, L^{\psi'}\rangle$ be a $(\mathbb{B}_{\rank}, \{ R_{\phi}
  \})$-circuit such that
  \begin{itemizens}
  \item $G^{\psi'} = G_{\text{out}} \cup G_{\text{in}}$,
  \item $\Omega^{\psi'}$ be an injection from $[n]^k$ to $G^{\psi'}$ defined by
    $\Omega^{\psi'}(\vec{c}) = g_{\vec{c}}$ for all $\vec{c} \in [n]^k$,
  \item $\Sigma^{\psi'} (g) = \rank^r_p$ if $g \in G_{\text{out}}$ and
    $\Sigma^{\psi'}(g) = R_\phi$ if $g \in G_{\text{in}}$,
  \item for each $(\vec{a}, \vec{b}, \vec{c}) \in [n]^{k_1 +k_2 + k}$,
    $\Lambda^{\psi'} (\vec{a}, \vec{b}, \vec{c}) = g_{\vec{a}, \vec{b},
      \vec{c}}$, and
  \item for each gate $g_{\vec{c}} \in G_{\text{out}}$, $L(g_{\vec{c}}):
    [n]^{k_1} \times [n]^{k_2} \rightarrow G^{\psi'}$ is defined by
    $L(g_{\vec{c}})(\vec{a}, \vec{b}) := g_{\vec{a}, \vec{b}, \vec{c}}$ for each
    $\vec{a} \in [n]^{k_1}$ and $\vec{b} \in [n]^{k_2}$.
  \end{itemizens}

  We note that $C^{\psi'}_n$ translates $\psi (\vec{y})$ at $n$. Let $R$ be a
  relation symbol in $\tau$. Let
  \begin{align*} T_n(\psi(\vec{y})) := \op{compose-and-tag}(C^{\psi'}_n,
    (T_n(\phi(\vec{z}, \vec{w}, \vec{y}))), (R_\phi), R).
  \end{align*}

  We recall that $\op{compose-and-tag}$ combines circuits in a similar way to
  $\op{compose}$ except that it also adds a set of gadgets to the circuit
  ensuring that no two child gates of an output gate are
  syntactically-equivalent. We thus have that $T_n(\psi (\vec{y}))$ is
  transparent if $T_n(\phi (\vec{z}, \vec{w},\vec{y}))$ is transparent, and
  $T_n(\psi(\vec{y}))$ translates $\psi (\vec{y})$ at $n$ if $T_n(\phi (\vec{z},
  \vec{w},\vec{y}))$ translates $\phi(\vec{z}, \vec{w}, \vec{y})$ at $n$.

  We have completed our definition of $T_n$ and shown, by induction on the
  structure of $\theta_n(\vec{x})$, that for each $\psi (\vec{y})$ a sub-formula
  of $\theta_n(\vec{x})$, $T_n(\psi(\vec{y}))$ translates $\psi(\vec{y})$ at
  $n$.

  The above definition can be used to define a recursive algorithm computing the
  function $n \mapsto T_n (\theta_n(\vec{x}))$. We note that, since
  $\width(\theta_n) \leq 4 t$ for all $n \in \nats$, there are only a finite
  number of cases that need to be considered at each recursive step in this
  algorithm. This fact can be used to show that there exists a polynomial bound
  on the running time of the algorithm that depends only on $n$ and the
  structure of $\theta(\vec{x})$. As such, we have that $(T_n (\theta_n))_{n \in
    \nats}$ translates $\theta(\vec{x})$, and the result follows.
\end{proof}

\bibliography{../references.bib}
% \ifcsdef{mainfile}{}{\bibliography{../references.bib}}
\end{document}
